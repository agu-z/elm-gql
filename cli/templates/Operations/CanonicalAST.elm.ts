export default (): string => "module GraphQL.Operations.CanonicalAST exposing (..)\n\nimport Elm\nimport Elm.Annotation as Type\nimport Elm.Op\nimport Gen.GraphQL.Engine as Engine\nimport Gen.GraphQL.Operations.AST as GenAST\nimport Gen.GraphQL.Operations.CanonicalAST as GenCan\nimport Gen.GraphQL.Schema as GenSchema\nimport Gen.String\nimport GraphQL.Operations.AST as AST\nimport GraphQL.Schema\n\n\ntype alias Document =\n    { definitions : List Definition\n    }\n\n\ntype Definition\n    = Operation OperationDetails\n\n\ntype alias OperationDetails =\n    { operationType : OperationType\n    , name : Maybe Name\n    , variableDefinitions : List VariableDefinition\n    , directives : List Directive\n    , fields : List Selection\n    }\n\n\ntype OperationType\n    = Query\n    | Mutation\n\n\ntype alias Directive =\n    { name : Name\n    , arguments : List Argument\n    }\n\n\ntype alias Argument =\n    AST.Argument\n\n\ntype alias VariableDefinition =\n    { variable : Variable\n    , type_ : AST.Type\n    , defaultValue : Maybe AST.Value\n    , schemaType : GraphQL.Schema.Type\n    }\n\n\ntype alias Variable =\n    { name : Name\n    }\n\n\ntype Selection\n    = FieldObject FieldObjectDetails\n    | FieldUnion FieldUnionDetails\n    | FieldScalar FieldScalarDetails\n    | FieldEnum FieldEnumDetails\n    | FieldInterface FieldInterfaceDetails\n\n\nisTypeNameSelection : Selection -> Bool\nisTypeNameSelection sel =\n    case sel of\n        FieldScalar scal ->\n            nameToString scal.name == \"__typename\"\n\n        _ ->\n            False\n\n\ntype alias FieldDetails =\n    { alias_ : Maybe Name\n    , name : Name\n    , arguments : List Argument\n    , directives : List Directive\n    , selection : List Selection\n    }\n\n\n{-|\n\n    - name        -> the field name in the schema\n    - alias_      -> the alias provided in the query\n    - globalAlias ->\n            The name that's guaranteed to be unique for the query.\n            This is used to generate record types for the results of an operation.\n\n-}\ntype alias FieldObjectDetails =\n    { alias_ : Maybe Name\n    , name : Name\n    , globalAlias : Name\n    , arguments : List Argument\n    , directives : List Directive\n    , selection : List Selection\n    , wrapper : GraphQL.Schema.Wrapped\n    }\n\n\ntype alias FieldUnionDetails =\n    { alias_ : Maybe Name\n    , name : Name\n    , globalAlias : Name\n    , arguments : List Argument\n    , directives : List Directive\n    , selection : List Selection\n    , variants : List UnionCaseDetails\n    , remainingTags :\n        List\n            { tag : Name\n            , globalAlias : Name\n            }\n    , wrapper : GraphQL.Schema.Wrapped\n    }\n\n\ntype alias FieldInterfaceDetails =\n    { alias_ : Maybe Name\n    , name : Name\n    , globalAlias : Name\n    , arguments : List Argument\n    , directives : List Directive\n    , selection : List Selection\n    , variants : List InterfaceCase\n    , remainingTags :\n        List\n            { tag : Name\n            , globalAlias : Name\n            }\n    , wrapper : GraphQL.Schema.Wrapped\n    }\n\n\ntype alias InterfaceCase =\n    { tag : Name\n    , globalAlias : Name\n    , directives : List Directive\n    , selection : List Selection\n    }\n\n\ntype alias FieldScalarDetails =\n    { alias_ : Maybe Name\n    , name : Name\n    , arguments : List Argument\n    , directives : List Directive\n    , type_ : GraphQL.Schema.Type\n    }\n\n\ntype alias FieldEnumDetails =\n    { alias_ : Maybe Name\n    , name : Name\n    , arguments : List Argument\n    , directives : List Directive\n    , enumName : String\n    , values : List { name : String, description : Maybe String }\n    , wrapper : GraphQL.Schema.Wrapped\n    }\n\n\ntype alias UnionCaseDetails =\n    { tag : Name\n    , globalAlias : Name\n    , directives : List Directive\n    , selection : List Selection\n    }\n\n\ntype Name\n    = Name String\n\n\ngetAliasedName : Selection -> String\ngetAliasedName sel =\n    case sel of\n        FieldObject details ->\n            nameToString (Maybe.withDefault details.name details.alias_)\n\n        FieldUnion details ->\n            nameToString (Maybe.withDefault details.name details.alias_)\n\n        FieldScalar details ->\n            nameToString (Maybe.withDefault details.name details.alias_)\n\n        FieldEnum details ->\n            nameToString (Maybe.withDefault details.name details.alias_)\n\n        FieldInterface details ->\n            nameToString (Maybe.withDefault details.name details.alias_)\n\n\ngetAliasedFieldName :\n    { field\n        | alias_ : Maybe Name\n        , name : Name\n    }\n    -> String\ngetAliasedFieldName details =\n    nameToString (Maybe.withDefault details.name details.alias_)\n\n\nnameToString : Name -> String\nnameToString (Name str) =\n    str\n\n\n\n{- To String -}\n\n\n{-| -}\ntoString : Definition -> String\ntoString (Operation def) =\n    let\n        opName =\n            case def.name of\n                Nothing ->\n                    \"\"\n\n                Just (Name str) ->\n                    str\n\n        variableDefinitions =\n            case def.variableDefinitions of\n                [] ->\n                    \"\"\n\n                vars ->\n                    let\n                        renderedVars =\n                            foldToString \", \"\n                                (\\var ->\n                                    \"$\"\n                                        ++ nameToString var.variable.name\n                                        ++ \": \"\n                                        ++ typeToString (getWrapper var.type_ (Val { required = True })) var.type_\n                                )\n                                vars\n                    in\n                    \"(\" ++ renderedVars ++ \")\"\n    in\n    operationName def.operationType\n        ++ \" \"\n        ++ opName\n        ++ variableDefinitions\n        ++ \" \"\n        ++ brackets\n            (foldToString \"\\n\" selectionToString def.fields)\n\n\n{-| Only render the fields of the query, but with no outer brackets\n-}\noperationLabel : Definition -> Maybe String\noperationLabel (Operation def) =\n    case def.name of\n        Nothing ->\n            Nothing\n\n        Just (Name str) ->\n            Just str\n\n\n{-| Only render the fields of the query, but with no outer brackets\n-}\ntoStringFields : Definition -> String\ntoStringFields (Operation def) =\n    foldToString \"\\n\" selectionToString def.fields\n\n\nselectionToString : Selection -> String\nselectionToString sel =\n    case sel of\n        FieldObject details ->\n            aliasedName details\n                ++ renderArguments details.arguments\n                ++ renderSelection details.selection\n\n        FieldUnion details ->\n            aliasedName details\n                ++ renderArguments details.arguments\n                ++ \" \"\n                ++ brackets\n                    (foldToString \"\\n\" selectionToString details.selection\n                        ++ (if not (List.isEmpty details.selection && List.isEmpty details.variants) then\n                                \"\\n\"\n\n                            else\n                                \"\"\n                           )\n                        ++ foldToString \"\\n\" variantFragmentToString details.variants\n                    )\n\n        FieldScalar details ->\n            aliasedName details ++ renderArguments details.arguments\n\n        FieldEnum details ->\n            aliasedName details ++ renderArguments details.arguments\n\n        FieldInterface details ->\n            aliasedName details\n                ++ renderArguments details.arguments\n                ++ \" \"\n                ++ brackets\n                    (foldToString \"\\n\" selectionToString details.selection\n                        ++ (if not (List.isEmpty details.selection && List.isEmpty details.variants) then\n                                \"\\n\"\n\n                            else\n                                \"\"\n                           )\n                        ++ foldToString \"\\n\" variantFragmentToString details.variants\n                    )\n\n\nvariantFragmentToString : UnionCaseDetails -> String\nvariantFragmentToString instance =\n    \"... on \"\n        ++ nameToString instance.tag\n        ++ \" \"\n        ++ brackets (foldToString \"\\n\" selectionToString instance.selection)\n\n\nrenderSelection : List Selection -> String\nrenderSelection selection =\n    case selection of\n        [] ->\n            \"\"\n\n        _ ->\n            \" \"\n                ++ brackets (foldToString \"\\n\" selectionToString selection)\n\n\nrenderArguments : List Argument -> String\nrenderArguments args =\n    case args of\n        [] ->\n            \"\"\n\n        _ ->\n            \"(\"\n                ++ foldToString \"\\n\" argToString args\n                ++ \")\"\n\n\nargToString : Argument -> String\nargToString arg =\n    AST.nameToString arg.name ++ \": \" ++ argValToString arg.value\n\n\nargValToString : AST.Value -> String\nargValToString val =\n    case val of\n        AST.Str str ->\n            \"\\\"\" ++ str ++ \"\\\"\"\n\n        AST.Integer int ->\n            String.fromInt int\n\n        AST.Decimal dec ->\n            String.fromFloat dec\n\n        AST.Boolean True ->\n            \"true\"\n\n        AST.Boolean False ->\n            \"false\"\n\n        AST.Null ->\n            \"null\"\n\n        AST.Enum (AST.Name str) ->\n            str\n\n        AST.Var var ->\n            \"$\" ++ AST.nameToString var.name\n\n        AST.Object keyVals ->\n            brackets\n                (foldToString \", \"\n                    (\\( key, innerVal ) ->\n                        AST.nameToString key ++ \": \" ++ argValToString innerVal\n                    )\n                    keyVals\n                )\n\n        AST.ListValue vals ->\n            \"[\"\n                ++ foldToString \", \" argValToString vals\n                ++ \"]\"\n\n\naliasedName : { a | alias_ : Maybe Name, name : Name } -> String\naliasedName details =\n    case details.alias_ of\n        Nothing ->\n            nameToString details.name\n\n        Just alias_ ->\n            nameToString alias_ ++ \": \" ++ nameToString details.name\n\n\nfoldToString : String -> (a -> String) -> List a -> String\nfoldToString delimiter fn vals =\n    List.foldl\n        (\\var rendered ->\n            let\n                val =\n                    fn var\n            in\n            case rendered of\n                \"\" ->\n                    val\n\n                _ ->\n                    val ++ delimiter ++ rendered\n        )\n        \"\"\n        vals\n\n\noperationName : OperationType -> String\noperationName opType =\n    case opType of\n        Query ->\n            \"query\"\n\n        Mutation ->\n            \"mutation\"\n\n\nbrackets : String -> String\nbrackets str =\n    \"{\" ++ str ++ \"}\"\n\n\ntype Wrapper\n    = InList { required : Bool } Wrapper\n    | Val { required : Bool }\n\n\n{-|\n\n    Type ->\n        Required Val\n\n    Nullable Type ->\n        Val\n\n-}\ngetWrapper : AST.Type -> Wrapper -> Wrapper\ngetWrapper t wrap =\n    case t of\n        AST.Type_ _ ->\n            wrap\n\n        AST.List_ inner ->\n            getWrapper inner (InList { required = True } wrap)\n\n        AST.Nullable inner ->\n            case wrap of\n                Val { required } ->\n                    getWrapper inner (Val { required = False })\n\n                InList { required } wrapper ->\n                    getWrapper inner (InList { required = False } wrapper)\n\n\ntypeToString : Wrapper -> AST.Type -> String\ntypeToString wrapper t =\n    case t of\n        AST.Type_ (AST.Name str) ->\n            unwrap wrapper str\n\n        AST.List_ inner ->\n            typeToString wrapper inner\n\n        AST.Nullable inner ->\n            typeToString wrapper inner\n\n\nunwrap : Wrapper -> String -> String\nunwrap wrapper str =\n    case wrapper of\n        Val { required } ->\n            if required then\n                str ++ \"!\"\n\n            else\n                str\n\n        InList { required } inner ->\n            if required then\n                unwrap inner (\"[\" ++ str ++ \"!]\")\n\n            else\n                unwrap inner (\"[\" ++ str ++ \"]\")\n\n\ntoExpression : Definition -> Elm.Expression\ntoExpression (Operation op) =\n    GenCan.make_.operation\n        (GenCan.make_.operationDetails\n            { operationType = opTypeToExp op.operationType\n            , name =\n                case op.name of\n                    Nothing ->\n                        Elm.nothing\n\n                    Just name ->\n                        Elm.just (nameToExp name)\n            , variableDefinitions = Elm.list (List.map varDefToExp op.variableDefinitions)\n            , directives = Elm.list (List.map directiveToExp op.directives)\n            , fields =\n                Elm.list (List.map fieldToExp op.fields)\n            }\n        )\n        |> Elm.withType GenCan.annotation_.definition\n\n\ndirectiveToExp : Directive -> Elm.Expression\ndirectiveToExp dir =\n    GenCan.make_.directive\n        { name = nameToExp dir.name\n        , arguments =\n            Elm.list (List.map argToExp dir.arguments)\n        }\n\n\nargToExp : AST.Argument -> Elm.Expression\nargToExp arg =\n    GenAST.make_.argument\n        { name = astNameToExp arg.name\n        , value =\n            astValueToExp arg.value\n        }\n\n\nastValueToExp : AST.Value -> Elm.Expression\nastValueToExp val =\n    case val of\n        AST.Str str ->\n            GenAST.make_.str (Elm.string str)\n\n        AST.Integer int ->\n            GenAST.make_.integer (Elm.int int)\n\n        AST.Decimal float ->\n            GenAST.make_.decimal (Elm.float float)\n\n        AST.Boolean bool ->\n            GenAST.make_.boolean (Elm.bool bool)\n\n        AST.Null ->\n            GenAST.make_.null\n\n        AST.Enum name ->\n            GenAST.make_.enum (astNameToExp name)\n\n        AST.Var var ->\n            GenAST.make_.var\n                (GenAST.make_.variable\n                    { name = astNameToExp var.name }\n                )\n\n        AST.Object fields ->\n            GenAST.make_.object\n                (Elm.list\n                    (List.map\n                        (\\( name, fieldVal ) ->\n                            Elm.tuple\n                                (astNameToExp name)\n                                (astValueToExp fieldVal)\n                        )\n                        fields\n                    )\n                )\n\n        AST.ListValue vals ->\n            GenAST.make_.listValue\n                (Elm.list\n                    (List.map\n                        astValueToExp\n                        vals\n                    )\n                )\n\n\nastNameToExp : AST.Name -> Elm.Expression\nastNameToExp (AST.Name name) =\n    GenAST.make_.name (Elm.string name)\n\n\nopTypeToExp : OperationType -> Elm.Expression\nopTypeToExp op =\n    case op of\n        Query ->\n            GenCan.make_.query\n\n        Mutation ->\n            GenCan.make_.mutation\n\n\nnameToExp : Name -> Elm.Expression\nnameToExp (Name name) =\n    GenCan.make_.name (Elm.string name)\n\n\nvarDefToExp : VariableDefinition -> Elm.Expression\nvarDefToExp def =\n    GenCan.make_.variableDefinition\n        { variable = varToExp def.variable\n        , type_ = typeToExp def.type_\n        , defaultValue =\n            case def.defaultValue of\n                Nothing ->\n                    Elm.nothing\n\n                Just default ->\n                    Elm.just (astValueToExp default)\n        , schemaType =\n            schemaTypeToExp def.schemaType\n        }\n\n\nschemaTypeToExp : GraphQL.Schema.Type -> Elm.Expression\nschemaTypeToExp schemaType =\n    case schemaType of\n        GraphQL.Schema.Scalar scalar ->\n            GenSchema.make_.scalar (Elm.string scalar)\n\n        GraphQL.Schema.InputObject inputObj ->\n            GenSchema.make_.inputObject (Elm.string inputObj)\n\n        GraphQL.Schema.Object obj ->\n            GenSchema.make_.object (Elm.string obj)\n\n        GraphQL.Schema.Enum enum ->\n            GenSchema.make_.enum (Elm.string enum)\n\n        GraphQL.Schema.Union union ->\n            GenSchema.make_.union (Elm.string union)\n\n        GraphQL.Schema.Interface interface ->\n            GenSchema.make_.interface (Elm.string interface)\n\n        GraphQL.Schema.List_ inner ->\n            GenSchema.make_.list_ (schemaTypeToExp inner)\n\n        GraphQL.Schema.Nullable inner ->\n            GenSchema.make_.scalar (schemaTypeToExp inner)\n\n\nvarToExp : Variable -> Elm.Expression\nvarToExp var =\n    GenCan.make_.variable\n        { name = nameToExp var.name }\n\n\ntypeToExp : AST.Type -> Elm.Expression\ntypeToExp type_ =\n    case type_ of\n        AST.Type_ name ->\n            GenAST.make_.type_\n                (astNameToExp name)\n\n        AST.List_ inner ->\n            GenAST.make_.list_\n                (typeToExp inner)\n\n        AST.Nullable inner ->\n            GenAST.make_.nullable\n                (typeToExp inner)\n\n\nmaybeExp : (a -> Elm.Expression) -> Maybe a -> Elm.Expression\nmaybeExp toExp maybeVal =\n    case maybeVal of\n        Nothing ->\n            Elm.nothing\n\n        Just val ->\n            Elm.just (toExp val)\n\n\nschemaWrapperToExp : GraphQL.Schema.Wrapped -> Elm.Expression\nschemaWrapperToExp wrapped =\n    case wrapped of\n        GraphQL.Schema.UnwrappedValue ->\n            GenSchema.make_.unwrappedValue\n\n        GraphQL.Schema.InList inner ->\n            GenSchema.make_.inList (schemaWrapperToExp inner)\n\n        GraphQL.Schema.InMaybe inner ->\n            GenSchema.make_.inMaybe (schemaWrapperToExp inner)\n\n\nfieldToExp : Selection -> Elm.Expression\nfieldToExp sel =\n    case sel of\n        FieldObject details ->\n            GenCan.make_.fieldObject\n                (GenCan.make_.fieldObjectDetails\n                    { alias_ = maybeExp nameToExp details.alias_\n                    , name = nameToExp details.name\n                    , globalAlias = nameToExp details.globalAlias\n                    , arguments = Elm.list (List.map argToExp details.arguments)\n                    , directives = Elm.list (List.map directiveToExp details.directives)\n                    , selection = Elm.list (List.map fieldToExp details.selection)\n                    , wrapper = schemaWrapperToExp details.wrapper\n                    }\n                )\n\n        FieldUnion details ->\n            GenCan.make_.fieldUnion\n                (GenCan.make_.fieldUnionDetails\n                    { alias_ = maybeExp nameToExp details.alias_\n                    , name = nameToExp details.name\n                    , globalAlias = nameToExp details.globalAlias\n                    , arguments = Elm.list (List.map argToExp details.arguments)\n                    , directives = Elm.list (List.map directiveToExp details.directives)\n                    , selection = Elm.list (List.map fieldToExp details.selection)\n                    , wrapper = schemaWrapperToExp details.wrapper\n                    , variants = Elm.list (List.map unionVariantToExp details.variants)\n                    , remainingTags = Elm.list (List.map remainingTagsToExp details.remainingTags)\n                    }\n                )\n\n        FieldScalar details ->\n            GenCan.make_.fieldScalar\n                (GenCan.make_.fieldScalarDetails\n                    { alias_ = maybeExp nameToExp details.alias_\n                    , name = nameToExp details.name\n                    , arguments = Elm.list (List.map argToExp details.arguments)\n                    , directives = Elm.list (List.map directiveToExp details.directives)\n                    , type_ =\n                        schemaTypeToExp details.type_\n                    }\n                )\n\n        FieldEnum details ->\n            GenCan.make_.fieldEnum\n                (GenCan.make_.fieldEnumDetails\n                    { alias_ = maybeExp nameToExp details.alias_\n                    , name = nameToExp details.name\n                    , arguments = Elm.list (List.map argToExp details.arguments)\n                    , directives = Elm.list (List.map directiveToExp details.directives)\n                    , enumName = Elm.string details.enumName\n                    , values = Elm.list (List.map enumValueToExp details.values)\n                    , wrapper = schemaWrapperToExp details.wrapper\n                    }\n                )\n\n        FieldInterface details ->\n            GenCan.make_.fieldUnion\n                (GenCan.make_.fieldUnionDetails\n                    { alias_ = maybeExp nameToExp details.alias_\n                    , name = nameToExp details.name\n                    , globalAlias = nameToExp details.globalAlias\n                    , arguments = Elm.list (List.map argToExp details.arguments)\n                    , directives = Elm.list (List.map directiveToExp details.directives)\n                    , selection = Elm.list (List.map fieldToExp details.selection)\n                    , wrapper = schemaWrapperToExp details.wrapper\n                    , variants = Elm.list (List.map interfaceCaseToExp details.variants)\n                    , remainingTags = Elm.list (List.map remainingTagsToExp details.remainingTags)\n                    }\n                )\n\n\nenumValueToExp : { name : String, description : Maybe String } -> Elm.Expression\nenumValueToExp names =\n    Elm.record\n        [ ( \"name\", Elm.string names.name )\n        , ( \"description\", maybeExp Elm.string names.description )\n        ]\n\n\nremainingTagsToExp :\n    { tag : Name\n    , globalAlias : Name\n    }\n    -> Elm.Expression\nremainingTagsToExp remain =\n    Elm.record\n        [ ( \"tag\", nameToExp remain.tag )\n        , ( \"globalAlias\", nameToExp remain.globalAlias )\n        ]\n\n\nunionVariantToExp : UnionCaseDetails -> Elm.Expression\nunionVariantToExp union =\n    GenCan.make_.unionCaseDetails\n        { tag = nameToExp union.tag\n        , globalAlias = nameToExp union.globalAlias\n        , directives = Elm.list (List.map directiveToExp union.directives)\n        , selection = Elm.list (List.map fieldToExp union.selection)\n        }\n\n\ninterfaceCaseToExp : InterfaceCase -> Elm.Expression\ninterfaceCaseToExp interface =\n    GenCan.make_.interfaceCase\n        { tag = nameToExp interface.tag\n        , globalAlias = nameToExp interface.globalAlias\n        , directives = Elm.list (List.map directiveToExp interface.directives)\n        , selection = Elm.list (List.map fieldToExp interface.selection)\n        }\n\n\n\n{- TO RENDERER -}\n\n\n{-| We want to render a string of this, but with a `version`\n\nThe version is an Int, which represents if there are other queries batched with it.\n\n-}\ntoRendererExpression : Elm.Expression -> Definition -> Elm.Expression\ntoRendererExpression version (Operation def) =\n    initCursor version\n        |> renderFields def.fields\n        |> commit\n        |> (\\cursor ->\n                Maybe.withDefault (Elm.string \"\") cursor.exp\n           )\n\n\nrenderFields fields cursor =\n    List.foldr\n        (\\sel ( afterFirst, c ) ->\n            ( True\n            , c\n                |> addString\n                    (if afterFirst then\n                        \"\\n\"\n\n                     else\n                        \"\"\n                    )\n                |> selectionToExpressionString sel\n            )\n        )\n        ( False, cursor )\n        fields\n        |> Tuple.second\n\n\ninitCursor : Elm.Expression -> RenderingCursor\ninitCursor version =\n    { string = \"\"\n    , exp = Nothing\n    , depth = 0\n    , version = version\n    }\n\n\ntype alias RenderingCursor =\n    { string : String\n    , exp : Maybe Elm.Expression\n    , depth : Int\n    , version : Elm.Expression\n    }\n\n\naddLevelToCursor : RenderingCursor -> RenderingCursor\naddLevelToCursor cursor =\n    { cursor | depth = cursor.depth + 1 }\n\n\nremoveLevelToCursor : RenderingCursor -> RenderingCursor\nremoveLevelToCursor cursor =\n    { cursor | depth = cursor.depth - 1 }\n\n\ncommit : RenderingCursor -> RenderingCursor\ncommit cursor =\n    case cursor.string of\n        \"\" ->\n            cursor\n\n        _ ->\n            { cursor\n                | string = \"\"\n                , exp =\n                    case cursor.exp of\n                        Nothing ->\n                            Just (Elm.string cursor.string)\n\n                        Just existing ->\n                            Just\n                                (Elm.Op.append existing (Elm.string cursor.string))\n\n                -- (Gen.String.call_.append existing (Elm.string cursor.string))\n                -- (Elm.string cursor.string\n                --     |> Elm.Op.pipe\n                --         (Elm.apply Gen.String.values_.append [ existing ])\n                -- )\n            }\n\n\naddString : String -> RenderingCursor -> RenderingCursor\naddString str cursor =\n    case str of\n        \"\" ->\n            cursor\n\n        _ ->\n            { cursor | string = cursor.string ++ str }\n\n\naddExp : Elm.Expression -> RenderingCursor -> RenderingCursor\naddExp new cursor =\n    let\n        committed =\n            commit cursor\n    in\n    { committed\n        | exp =\n            case committed.exp of\n                Nothing ->\n                    Just new\n\n                Just existing ->\n                    Just\n                        (Elm.Op.append existing new)\n    }\n\n\nselectionToExpressionString : Selection -> RenderingCursor -> RenderingCursor\nselectionToExpressionString sel cursor =\n    case sel of\n        FieldObject details ->\n            cursor\n                |> aliasedNameExp details\n                |> renderArgumentsExp details.arguments\n                |> renderSelectionExp details.selection\n\n        FieldUnion details ->\n            cursor\n                |> aliasedNameExp details\n                |> renderArgumentsExp details.arguments\n                |> addString \" {\"\n                |> addLevelToCursor\n                |> renderFields details.selection\n                |> removeLevelToCursor\n                |> addString\n                    (if not (List.isEmpty details.selection && List.isEmpty details.variants) then\n                        \"\\n\"\n\n                     else\n                        \"\"\n                    )\n                |> addLevelToCursor\n                |> (\\currentCursor ->\n                        List.foldr renderVariantFragmentToExp currentCursor details.variants\n                   )\n                |> removeLevelToCursor\n                |> addString \" }\"\n\n        FieldScalar details ->\n            cursor\n                |> aliasedNameExp details\n                |> renderArgumentsExp details.arguments\n\n        FieldEnum details ->\n            cursor\n                |> aliasedNameExp details\n                |> renderArgumentsExp details.arguments\n\n        FieldInterface details ->\n            cursor\n                |> aliasedNameExp details\n                |> renderArgumentsExp details.arguments\n                |> addString \" {\"\n                |> renderFields details.selection\n                |> addString\n                    (if not (List.isEmpty details.selection && List.isEmpty details.variants) then\n                        \"\\n\"\n\n                     else\n                        \"\"\n                    )\n                |> (\\currentCursor ->\n                        List.foldr renderVariantFragmentToExp currentCursor details.variants\n                   )\n                |> addString \" }\"\n\n\naliasedNameExp : { a | alias_ : Maybe Name, name : Name } -> RenderingCursor -> RenderingCursor\naliasedNameExp details cursor =\n    if cursor.depth == 0 then\n        case details.alias_ of\n            Nothing ->\n                cursor\n                    |> addExp\n                        (Engine.call_.versionedAlias\n                            cursor.version\n                            (Elm.string (nameToString details.name))\n                        )\n\n            Just alias_ ->\n                cursor\n                    |> addExp\n                        (Engine.call_.versionedName\n                            cursor.version\n                            (Elm.string (nameToString alias_))\n                        )\n                    |> addString (\": \" ++ nameToString details.name)\n\n    else\n        case details.alias_ of\n            Nothing ->\n                cursor\n                    |> addString (nameToString details.name)\n\n            Just alias_ ->\n                cursor\n                    |> addString\n                        (nameToString alias_ ++ \": \" ++ nameToString details.name)\n\n\nrenderArgumentsExp : List Argument -> RenderingCursor -> RenderingCursor\nrenderArgumentsExp args cursor =\n    case args of\n        [] ->\n            cursor\n\n        _ ->\n            List.foldr\n                (\\arg ( afterFirst, curs ) ->\n                    ( True\n                    , curs\n                        |> addString\n                            (if afterFirst then\n                                \", \"\n\n                             else\n                                \"\"\n                            )\n                        |> addString (AST.nameToString arg.name ++ \": \")\n                        |> addArgValue arg.value\n                    )\n                )\n                ( False\n                , cursor\n                    |> addString \" (\"\n                )\n                args\n                |> Tuple.second\n                |> addString \")\"\n\n\naddArgValue : AST.Value -> RenderingCursor -> RenderingCursor\naddArgValue val cursor =\n    case val of\n        AST.Str str ->\n            cursor\n                |> addString (\"\\\"\" ++ str ++ \"\\\"\")\n\n        AST.Integer int ->\n            cursor\n                |> addString (String.fromInt int)\n\n        AST.Decimal dec ->\n            cursor\n                |> addString\n                    (String.fromFloat dec)\n\n        AST.Boolean True ->\n            cursor\n                |> addString \"true\"\n\n        AST.Boolean False ->\n            cursor\n                |> addString \"false\"\n\n        AST.Null ->\n            cursor\n                |> addString \"null\"\n\n        AST.Enum (AST.Name str) ->\n            cursor\n                |> addString str\n\n        AST.Var var ->\n            cursor\n                |> addExp\n                    (Engine.call_.versionedName\n                        cursor.version\n                        (Elm.string (\"$\" ++ AST.nameToString var.name))\n                    )\n\n        AST.Object keyVals ->\n            List.foldr\n                (\\( key, innerVal ) ( afterFirst, curs ) ->\n                    ( True\n                    , curs\n                        |> addString\n                            (if afterFirst then\n                                \", \"\n\n                             else\n                                \"\"\n                            )\n                        |> addString (AST.nameToString key ++ \": \")\n                        |> addArgValue innerVal\n                    )\n                )\n                ( False\n                , cursor\n                    |> addString \"{\"\n                )\n                keyVals\n                |> Tuple.second\n                |> addString \"}\"\n\n        AST.ListValue vals ->\n            List.foldr\n                (\\innerVal ( afterFirst, curs ) ->\n                    ( True\n                    , curs\n                        |> addString\n                            (if afterFirst then\n                                \", \"\n\n                             else\n                                \"\"\n                            )\n                        |> addArgValue innerVal\n                    )\n                )\n                ( False\n                , cursor\n                    |> addString \"[\"\n                )\n                vals\n                |> Tuple.second\n                |> addString \"]\"\n\n\nrenderSelectionExp : List Selection -> RenderingCursor -> RenderingCursor\nrenderSelectionExp selection cursor =\n    cursor\n        |> addString \" {\"\n        |> addLevelToCursor\n        |> renderFields selection\n        |> removeLevelToCursor\n        |> addString \"}\"\n\n\nrenderVariantFragmentToExp : UnionCaseDetails -> RenderingCursor -> RenderingCursor\nrenderVariantFragmentToExp instance cursor =\n    cursor\n        |> addString (\"\\n... on \" ++ nameToString instance.tag ++ \" {\")\n        |> addLevelToCursor\n        |> renderFields instance.selection\n        |> removeLevelToCursor\n        |> addString \"}\"\n"