export default (): string => "module GraphQL.Operations.CanonicalAST exposing (..)\n\nimport Elm\nimport Elm.Annotation as Type\nimport Gen.GraphQL.Operations.AST as GenAST\nimport Gen.GraphQL.Operations.CanonicalAST as GenCan\nimport Gen.GraphQL.Schema as GenSchema\nimport GraphQL.Operations.AST as AST\nimport GraphQL.Schema\n\n\ntype alias Document =\n    { definitions : List Definition\n    }\n\n\ntype Definition\n    = Operation OperationDetails\n\n\ntype alias OperationDetails =\n    { operationType : OperationType\n    , name : Maybe Name\n    , variableDefinitions : List VariableDefinition\n    , directives : List Directive\n    , fields : List Selection\n    }\n\n\ntype OperationType\n    = Query\n    | Mutation\n\n\ntype alias Directive =\n    { name : Name\n    , arguments : List Argument\n    }\n\n\ntype alias Argument =\n    AST.Argument\n\n\ntype alias VariableDefinition =\n    { variable : Variable\n    , type_ : AST.Type\n    , defaultValue : Maybe AST.Value\n    , schemaType : GraphQL.Schema.Type\n    }\n\n\ntype alias Variable =\n    { name : Name\n    }\n\n\ntype Selection\n    = FieldObject FieldObjectDetails\n    | FieldUnion FieldUnionDetails\n    | FieldScalar FieldScalarDetails\n    | FieldEnum FieldEnumDetails\n    | FieldInterface FieldInterfaceDetails\n\n\nisTypeNameSelection : Selection -> Bool\nisTypeNameSelection sel =\n    case sel of\n        FieldScalar scal ->\n            nameToString scal.name == \"__typename\"\n\n        _ ->\n            False\n\n\ntype alias FieldDetails =\n    { alias_ : Maybe Name\n    , name : Name\n    , arguments : List Argument\n    , directives : List Directive\n    , selection : List Selection\n    }\n\n\n{-|\n\n    - name        -> the field name in the schema\n    - alias_      -> the alias provided in the query\n    - globalAlias ->\n            The name that's guaranteed to be unique for the query.\n            This is used to generate record types for the results of an operation.\n\n-}\ntype alias FieldObjectDetails =\n    { alias_ : Maybe Name\n    , name : Name\n    , globalAlias : Name\n    , arguments : List Argument\n    , directives : List Directive\n    , selection : List Selection\n    , wrapper : GraphQL.Schema.Wrapped\n    }\n\n\ntype alias FieldUnionDetails =\n    { alias_ : Maybe Name\n    , name : Name\n    , globalAlias : Name\n    , arguments : List Argument\n    , directives : List Directive\n    , selection : List Selection\n    , variants : List UnionCaseDetails\n    , remainingTags :\n        List\n            { tag : Name\n            , globalAlias : Name\n            }\n    , wrapper : GraphQL.Schema.Wrapped\n    }\n\n\ntype alias FieldInterfaceDetails =\n    { alias_ : Maybe Name\n    , name : Name\n    , globalAlias : Name\n    , arguments : List Argument\n    , directives : List Directive\n    , selection : List Selection\n    , variants : List InterfaceCase\n    , remainingTags :\n        List\n            { tag : Name\n            , globalAlias : Name\n            }\n    , wrapper : GraphQL.Schema.Wrapped\n    }\n\n\ntype alias InterfaceCase =\n    { tag : Name\n    , globalAlias : Name\n    , directives : List Directive\n    , selection : List Selection\n    }\n\n\ntype alias FieldScalarDetails =\n    { alias_ : Maybe Name\n    , name : Name\n    , arguments : List Argument\n    , directives : List Directive\n    , type_ : GraphQL.Schema.Type\n    }\n\n\ntype alias FieldEnumDetails =\n    { alias_ : Maybe Name\n    , name : Name\n    , arguments : List Argument\n    , directives : List Directive\n    , enumName : String\n    , values : List { name : String, description : Maybe String }\n    , wrapper : GraphQL.Schema.Wrapped\n    }\n\n\ntype alias UnionCaseDetails =\n    { tag : Name\n    , globalAlias : Name\n    , directives : List Directive\n    , selection : List Selection\n    }\n\n\ntype Name\n    = Name String\n\n\ngetAliasedName : Selection -> String\ngetAliasedName sel =\n    case sel of\n        FieldObject details ->\n            nameToString (Maybe.withDefault details.name details.alias_)\n\n        FieldUnion details ->\n            nameToString (Maybe.withDefault details.name details.alias_)\n\n        FieldScalar details ->\n            nameToString (Maybe.withDefault details.name details.alias_)\n\n        FieldEnum details ->\n            nameToString (Maybe.withDefault details.name details.alias_)\n\n        FieldInterface details ->\n            nameToString (Maybe.withDefault details.name details.alias_)\n\n\ngetAliasedFieldName :\n    { field\n        | alias_ : Maybe Name\n        , name : Name\n    }\n    -> String\ngetAliasedFieldName details =\n    nameToString (Maybe.withDefault details.name details.alias_)\n\n\nnameToString : Name -> String\nnameToString (Name str) =\n    str\n\n\n\n{- To String -}\n\n\n{-| -}\ntoString : Definition -> String\ntoString (Operation def) =\n    let\n        opName =\n            case def.name of\n                Nothing ->\n                    \"\"\n\n                Just (Name str) ->\n                    str\n\n        variableDefinitions =\n            case def.variableDefinitions of\n                [] ->\n                    \"\"\n\n                vars ->\n                    let\n                        renderedVars =\n                            foldToString \", \"\n                                (\\var ->\n                                    \"$\"\n                                        ++ nameToString var.variable.name\n                                        ++ \": \"\n                                        ++ typeToString (getWrapper var.type_ (Val { required = True })) var.type_\n                                )\n                                vars\n                    in\n                    \"(\" ++ renderedVars ++ \")\"\n    in\n    operationName def.operationType\n        ++ \" \"\n        ++ opName\n        ++ variableDefinitions\n        ++ \" \"\n        ++ brackets\n            (foldToString \"\\n\" selectionToString def.fields)\n\n\n{-| Only render the fields of the query, but with no outer brackets\n-}\noperationLabel : Definition -> Maybe String\noperationLabel (Operation def) =\n    case def.name of\n        Nothing ->\n            Nothing\n\n        Just (Name str) ->\n            Just str\n\n\n{-| Only render the fields of the query, but with no outer brackets\n-}\ntoStringFields : Definition -> String\ntoStringFields (Operation def) =\n    let\n        opName =\n            case def.name of\n                Nothing ->\n                    \"\"\n\n                Just (Name str) ->\n                    str\n\n        variableDefinitions =\n            case def.variableDefinitions of\n                [] ->\n                    \"\"\n\n                vars ->\n                    let\n                        renderedVars =\n                            foldToString \", \"\n                                (\\var ->\n                                    \"$\"\n                                        ++ nameToString var.variable.name\n                                        ++ \": \"\n                                        ++ typeToString (getWrapper var.type_ (Val { required = True })) var.type_\n                                )\n                                vars\n                    in\n                    \"(\" ++ renderedVars ++ \")\"\n    in\n    foldToString \"\\n\" selectionToString def.fields\n\n\nselectionToString : Selection -> String\nselectionToString sel =\n    case sel of\n        FieldObject details ->\n            aliasedName details\n                ++ renderArguments details.arguments\n                ++ renderSelection details.selection\n\n        FieldUnion details ->\n            aliasedName details\n                ++ renderArguments details.arguments\n                ++ \" \"\n                ++ brackets\n                    (foldToString \"\\n\" selectionToString details.selection\n                        ++ (if not (List.isEmpty details.selection && List.isEmpty details.variants) then\n                                \"\\n\"\n\n                            else\n                                \"\"\n                           )\n                        ++ foldToString \"\\n\" variantFragmentToString details.variants\n                    )\n\n        FieldScalar details ->\n            aliasedName details ++ renderArguments details.arguments\n\n        FieldEnum details ->\n            aliasedName details ++ renderArguments details.arguments\n\n        FieldInterface details ->\n            aliasedName details\n                ++ renderArguments details.arguments\n                ++ \" \"\n                ++ brackets\n                    (foldToString \"\\n\" selectionToString details.selection\n                        ++ (if not (List.isEmpty details.selection && List.isEmpty details.variants) then\n                                \"\\n\"\n\n                            else\n                                \"\"\n                           )\n                        ++ foldToString \"\\n\" variantFragmentToString details.variants\n                    )\n\n\nvariantFragmentToString : UnionCaseDetails -> String\nvariantFragmentToString instance =\n    \"... on \"\n        ++ nameToString instance.tag\n        ++ \" \"\n        ++ brackets (foldToString \"\\n\" selectionToString instance.selection)\n\n\nrenderSelection : List Selection -> String\nrenderSelection selection =\n    case selection of\n        [] ->\n            \"\"\n\n        _ ->\n            \" \"\n                ++ brackets (foldToString \"\\n\" selectionToString selection)\n\n\nrenderArguments : List Argument -> String\nrenderArguments args =\n    case args of\n        [] ->\n            \"\"\n\n        _ ->\n            \"(\"\n                ++ foldToString \"\\n\" argToString args\n                ++ \")\"\n\n\nargToString : Argument -> String\nargToString arg =\n    AST.nameToString arg.name ++ \": \" ++ argValToString arg.value\n\n\nargValToString : AST.Value -> String\nargValToString val =\n    case val of\n        AST.Str str ->\n            \"\\\"\" ++ str ++ \"\\\"\"\n\n        AST.Integer int ->\n            String.fromInt int\n\n        AST.Decimal dec ->\n            String.fromFloat dec\n\n        AST.Boolean True ->\n            \"true\"\n\n        AST.Boolean False ->\n            \"false\"\n\n        AST.Null ->\n            \"null\"\n\n        AST.Enum (AST.Name str) ->\n            str\n\n        AST.Var var ->\n            \"$\" ++ AST.nameToString var.name\n\n        AST.Object keyVals ->\n            brackets\n                (foldToString \", \"\n                    (\\( key, innerVal ) ->\n                        AST.nameToString key ++ \": \" ++ argValToString innerVal\n                    )\n                    keyVals\n                )\n\n        AST.ListValue vals ->\n            \"[\"\n                ++ foldToString \", \" argValToString vals\n                ++ \"]\"\n\n\naliasedName : { a | alias_ : Maybe Name, name : Name } -> String\naliasedName details =\n    case details.alias_ of\n        Nothing ->\n            nameToString details.name\n\n        Just alias_ ->\n            nameToString alias_ ++ \": \" ++ nameToString details.name\n\n\nfoldToString : String -> (a -> String) -> List a -> String\nfoldToString delimiter fn vals =\n    List.foldl\n        (\\var rendered ->\n            let\n                val =\n                    fn var\n            in\n            case rendered of\n                \"\" ->\n                    val\n\n                _ ->\n                    val ++ delimiter ++ rendered\n        )\n        \"\"\n        vals\n\n\noperationName : OperationType -> String\noperationName opType =\n    case opType of\n        Query ->\n            \"query\"\n\n        Mutation ->\n            \"mutation\"\n\n\nbrackets : String -> String\nbrackets str =\n    \"{\" ++ str ++ \"}\"\n\n\ntype Wrapper\n    = InList { required : Bool } Wrapper\n    | Val { required : Bool }\n\n\n{-|\n\n    Type ->\n        Required Val\n\n    Nullable Type ->\n        Val\n\n-}\ngetWrapper : AST.Type -> Wrapper -> Wrapper\ngetWrapper t wrap =\n    case t of\n        AST.Type_ _ ->\n            wrap\n\n        AST.List_ inner ->\n            getWrapper inner (InList { required = True } wrap)\n\n        AST.Nullable inner ->\n            case wrap of\n                Val { required } ->\n                    getWrapper inner (Val { required = False })\n\n                InList { required } wrapper ->\n                    getWrapper inner (InList { required = False } wrapper)\n\n\ntypeToString : Wrapper -> AST.Type -> String\ntypeToString wrapper t =\n    case t of\n        AST.Type_ (AST.Name str) ->\n            unwrap wrapper str\n\n        AST.List_ inner ->\n            typeToString wrapper inner\n\n        AST.Nullable inner ->\n            typeToString wrapper inner\n\n\nunwrap : Wrapper -> String -> String\nunwrap wrapper str =\n    case wrapper of\n        Val { required } ->\n            if required then\n                str ++ \"!\"\n\n            else\n                str\n\n        InList { required } inner ->\n            if required then\n                unwrap inner (\"[\" ++ str ++ \"!]\")\n\n            else\n                unwrap inner (\"[\" ++ str ++ \"]\")\n\n\ntoExpression : Definition -> Elm.Expression\ntoExpression (Operation op) =\n    GenCan.make_.operation\n        (GenCan.make_.operationDetails\n            { operationType = opTypeToExp op.operationType\n            , name =\n                case op.name of\n                    Nothing ->\n                        Elm.nothing\n\n                    Just name ->\n                        Elm.just (nameToExp name)\n            , variableDefinitions = Elm.list (List.map varDefToExp op.variableDefinitions)\n            , directives = Elm.list (List.map directiveToExp op.directives)\n            , fields =\n                Elm.list (List.map fieldToExp op.fields)\n            }\n        )\n        |> Elm.withType GenCan.annotation_.definition\n\n\ndirectiveToExp : Directive -> Elm.Expression\ndirectiveToExp dir =\n    GenCan.make_.directive\n        { name = nameToExp dir.name\n        , arguments =\n            Elm.list (List.map argToExp dir.arguments)\n        }\n\n\nargToExp : AST.Argument -> Elm.Expression\nargToExp arg =\n    GenAST.make_.argument\n        { name = astNameToExp arg.name\n        , value =\n            astValueToExp arg.value\n        }\n\n\nastValueToExp : AST.Value -> Elm.Expression\nastValueToExp val =\n    case val of\n        AST.Str str ->\n            GenAST.make_.str (Elm.string str)\n\n        AST.Integer int ->\n            GenAST.make_.integer (Elm.int int)\n\n        AST.Decimal float ->\n            GenAST.make_.decimal (Elm.float float)\n\n        AST.Boolean bool ->\n            GenAST.make_.boolean (Elm.bool bool)\n\n        AST.Null ->\n            GenAST.make_.null\n\n        AST.Enum name ->\n            GenAST.make_.enum (astNameToExp name)\n\n        AST.Var var ->\n            GenAST.make_.var\n                (GenAST.make_.variable\n                    { name = astNameToExp var.name }\n                )\n\n        AST.Object fields ->\n            GenAST.make_.object\n                (Elm.list\n                    (List.map\n                        (\\( name, fieldVal ) ->\n                            Elm.tuple\n                                (astNameToExp name)\n                                (astValueToExp fieldVal)\n                        )\n                        fields\n                    )\n                )\n\n        AST.ListValue vals ->\n            GenAST.make_.listValue\n                (Elm.list\n                    (List.map\n                        astValueToExp\n                        vals\n                    )\n                )\n\n\nastNameToExp : AST.Name -> Elm.Expression\nastNameToExp (AST.Name name) =\n    GenAST.make_.name (Elm.string name)\n\n\nopTypeToExp : OperationType -> Elm.Expression\nopTypeToExp op =\n    case op of\n        Query ->\n            GenCan.make_.query\n\n        Mutation ->\n            GenCan.make_.mutation\n\n\nnameToExp : Name -> Elm.Expression\nnameToExp (Name name) =\n    GenCan.make_.name (Elm.string name)\n\n\nvarDefToExp : VariableDefinition -> Elm.Expression\nvarDefToExp def =\n    GenCan.make_.variableDefinition\n        { variable = varToExp def.variable\n        , type_ = typeToExp def.type_\n        , defaultValue =\n            case def.defaultValue of\n                Nothing ->\n                    Elm.nothing\n\n                Just default ->\n                    Elm.just (astValueToExp default)\n        , schemaType =\n            schemaTypeToExp def.schemaType\n        }\n\n\nschemaTypeToExp : GraphQL.Schema.Type -> Elm.Expression\nschemaTypeToExp schemaType =\n    case schemaType of\n        GraphQL.Schema.Scalar scalar ->\n            GenSchema.make_.scalar (Elm.string scalar)\n\n        GraphQL.Schema.InputObject inputObj ->\n            GenSchema.make_.inputObject (Elm.string inputObj)\n\n        GraphQL.Schema.Object obj ->\n            GenSchema.make_.object (Elm.string obj)\n\n        GraphQL.Schema.Enum enum ->\n            GenSchema.make_.enum (Elm.string enum)\n\n        GraphQL.Schema.Union union ->\n            GenSchema.make_.union (Elm.string union)\n\n        GraphQL.Schema.Interface interface ->\n            GenSchema.make_.interface (Elm.string interface)\n\n        GraphQL.Schema.List_ inner ->\n            GenSchema.make_.list_ (schemaTypeToExp inner)\n\n        GraphQL.Schema.Nullable inner ->\n            GenSchema.make_.scalar (schemaTypeToExp inner)\n\n\nvarToExp : Variable -> Elm.Expression\nvarToExp var =\n    GenCan.make_.variable\n        { name = nameToExp var.name }\n\n\ntypeToExp : AST.Type -> Elm.Expression\ntypeToExp type_ =\n    case type_ of\n        AST.Type_ name ->\n            GenAST.make_.type_\n                (astNameToExp name)\n\n        AST.List_ inner ->\n            GenAST.make_.list_\n                (typeToExp inner)\n\n        AST.Nullable inner ->\n            GenAST.make_.nullable\n                (typeToExp inner)\n\n\nmaybeExp : (a -> Elm.Expression) -> Maybe a -> Elm.Expression\nmaybeExp toExp maybeVal =\n    case maybeVal of\n        Nothing ->\n            Elm.nothing\n\n        Just val ->\n            Elm.just (toExp val)\n\n\nschemaWrapperToExp : GraphQL.Schema.Wrapped -> Elm.Expression\nschemaWrapperToExp wrapped =\n    case wrapped of\n        GraphQL.Schema.UnwrappedValue ->\n            GenSchema.make_.unwrappedValue\n\n        GraphQL.Schema.InList inner ->\n            GenSchema.make_.inList (schemaWrapperToExp inner)\n\n        GraphQL.Schema.InMaybe inner ->\n            GenSchema.make_.inMaybe (schemaWrapperToExp inner)\n\n\nfieldToExp : Selection -> Elm.Expression\nfieldToExp sel =\n    case sel of\n        FieldObject details ->\n            GenCan.make_.fieldObject\n                (GenCan.make_.fieldObjectDetails\n                    { alias_ = maybeExp nameToExp details.alias_\n                    , name = nameToExp details.name\n                    , globalAlias = nameToExp details.globalAlias\n                    , arguments = Elm.list (List.map argToExp details.arguments)\n                    , directives = Elm.list (List.map directiveToExp details.directives)\n                    , selection = Elm.list (List.map fieldToExp details.selection)\n                    , wrapper = schemaWrapperToExp details.wrapper\n                    }\n                )\n\n        FieldUnion details ->\n            Debug.todo \"\"\n\n        FieldScalar details ->\n            Debug.todo \"\"\n\n        FieldEnum details ->\n            Debug.todo \"\"\n\n        FieldInterface details ->\n            Debug.todo \"\"\n"