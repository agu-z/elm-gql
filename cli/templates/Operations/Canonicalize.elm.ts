export default (): string => "module GraphQL.Operations.Canonicalize exposing (canonicalize, cyan, errorToString)\n\n{-| -}\n\nimport Dict exposing (Dict)\nimport GraphQL.Operations.AST as AST\nimport GraphQL.Operations.CanonicalAST as Can\nimport GraphQL.Schema\n\n\ntype Error\n    = Error\n        { coords : Coords\n        , error : ErrorDetails\n        }\n\n\ntodo : String -> Error\ntodo msg =\n    Error\n        { coords =\n            { start = zeroPosition\n            , end = zeroPosition\n            }\n        , error = Todo msg\n        }\n\n\nerror : ErrorDetails -> Error\nerror deets =\n    Error\n        { coords = { start = zeroPosition, end = zeroPosition }\n        , error = deets\n        }\n\n\nzeroPosition : Position\nzeroPosition =\n    { line = 0\n    , char = 0\n    }\n\n\ntype alias Coords =\n    { start : Position\n    , end : Position\n    }\n\n\ntype alias Position =\n    { line : Int\n    , char : Int\n    }\n\n\ntype ErrorDetails\n    = QueryUnknown String\n    | EnumUnknown String\n    | ObjectUnknown String\n    | InterfaceUnknown String\n    | UnionUnknown String\n    | UnknownArgs\n        { field : String\n        , unknownArgs : List String\n        , allowedArgs : List GraphQL.Schema.Argument\n        }\n    | EmptySelection\n        { field : String\n        , fieldType : String\n        , options : List { field : String, type_ : String }\n        }\n    | FieldUnknown\n        { object : String\n        , field : String\n        }\n    | VariableIssueSummary VariableSummary\n    | FieldAliasRequired\n        { fieldName : String\n        }\n    | NonExhaustiveVariants\n        { unionName : String\n        , leftOver : List String\n        }\n    | MissingTypename\n        { tag : String\n        }\n    | EmptyUnionVariantSelection\n        { tag : String\n        }\n    | IncorrectInlineInput\n        { schema : GraphQL.Schema.Type\n        , arg : String\n        , found : AST.Value\n        }\n    | FragmentNotFound\n        { found : String\n        , object : String\n        , options :\n            List Can.Fragment\n        }\n    | FragmentTargetDoesntExist\n        { fragmentName : String\n        , typeCondition : String\n        }\n    | FragmentDuplicateFound\n        { firstName : String\n        , firstTypeCondition : String\n        , firstFieldCount : Int\n        , secondName : String\n        , secondTypeCondition : String\n        , secondFieldCount : Int\n        }\n    | Todo String\n\n\ntype alias VariableSummary =\n    { declared : List DeclaredVariable\n    , valid : List Can.VariableDefinition\n    , issues : List VarIssue\n    , suggestions : List SuggestedVariable\n    }\n\n\ntype alias DeclaredVariable =\n    { name : String\n    , type_ : Maybe String\n    }\n\n\ntype VarIssue\n    = Unused { name : String, possibly : List String }\n    | UnexpectedType\n        { name : String\n        , found : Maybe String\n        , expected : String\n        }\n    | Undeclared { name : String, possibly : List String }\n\n\ntype alias SuggestedVariable =\n    { name : String\n    , type_ : String\n    }\n\n\n\n{- Error rendering -}\n\n\n{-| An indented block with a newline above and below\n-}\nblock : List String -> String\nblock lines =\n    \"\\n    \" ++ String.join \"\\n    \" lines ++ \"\\n\"\n\n\n\n{-\n   If more colors are wanted, this is a good reference:\n   https://github.com/chalk/chalk/blob/main/source/vendor/ansi-styles/index.js\n-}\n\n\ncyan : String -> String\ncyan str =\n    color 36 39 str\n\n\nyellow : String -> String\nyellow str =\n    color 33 39 str\n\n\ngreen : String -> String\ngreen str =\n    color 32 39 str\n\n\nred : String -> String\nred str =\n    color 31 39 str\n\n\ngrey : String -> String\ngrey str =\n    color 90 39 str\n\n\ncolor : Int -> Int -> String -> String\ncolor openCode closeCode content =\n    let\n        delim code =\n            --\"\\\\u001B[\" ++ String.fromInt code ++ \"m\"\n            \"\\u{001B}[\" ++ String.fromInt code ++ \"m\"\n    in\n    delim openCode ++ content ++ delim closeCode\n\n\n\n{- -}\n\n\nerrorToString : Error -> String\nerrorToString (Error details) =\n    case details.error of\n        Todo msg ->\n            \"Todo: \" ++ msg\n\n        EnumUnknown name ->\n            String.join \"\\n\"\n                [ \"I don't recognize this name:\"\n                , block\n                    [ yellow name ]\n                ]\n\n        QueryUnknown name ->\n            String.join \"\\n\"\n                [ \"I don't recognize this query:\"\n                , block\n                    [ yellow name ]\n                ]\n\n        ObjectUnknown name ->\n            String.join \"\\n\"\n                [ \"I don't recognize this object:\"\n                , block\n                    [ yellow name ]\n                ]\n\n        InterfaceUnknown name ->\n            String.join \"\\n\"\n                [ \"I don't recognize this interface:\"\n                , block\n                    [ yellow name ]\n                ]\n\n        UnionUnknown name ->\n            String.join \"\\n\"\n                [ \"I don't recognize this union:\"\n                , block\n                    [ yellow name ]\n                ]\n\n        FieldUnknown field ->\n            String.join \"\\n\"\n                [ \"You're trying to access\"\n                , block\n                    [ cyan (field.object ++ \".\" ++ field.field)\n                    ]\n                , \"But I don't see a \" ++ cyan field.field ++ \" field on \" ++ cyan field.object\n                ]\n\n        UnknownArgs deets ->\n            case deets.allowedArgs of\n                [] ->\n                    String.join \"\\n\"\n                        [ yellow deets.field ++ \" has the following arguments:\"\n                        , block\n                            (List.map yellow deets.unknownArgs)\n                        , \"but the GQL schema says it can't have any!\"\n                        , \"Maybe the arguments are on the wrong field?\"\n                        ]\n\n                _ ->\n                    String.join \"\\n\"\n                        [ yellow deets.field ++ \" has these arguments, but I don't recognize them!\"\n                        , block\n                            (List.map yellow deets.unknownArgs)\n                        , \"Here are the arguments that this field can have:\"\n                        , block\n                            (List.map\n                                (\\opt ->\n                                    yellow opt.name ++ \": \" ++ cyan (GraphQL.Schema.typeToString opt.type_)\n                                )\n                                deets.allowedArgs\n                            )\n                        ]\n\n        EmptySelection deets ->\n            String.join \"\\n\"\n                [ \"This field isn't selecting anything\"\n                , block\n                    [ yellow deets.field ]\n                , \"But it is a \" ++ yellow deets.fieldType ++ \", which needs to select some fields.\"\n                , \"You can either remove it or select some of the following fields:\"\n                , block\n                    (List.map\n                        (\\opt ->\n                            yellow opt.field ++ \": \" ++ cyan opt.type_\n                        )\n                        deets.options\n                    )\n                ]\n\n        FieldAliasRequired deets ->\n            String.join \"\\n\"\n                [ \"I found two fields that have the same name:\"\n                , block\n                    [ yellow deets.fieldName ]\n                , \"Add an alias to one of them so there's no confusion!\"\n                ]\n\n        NonExhaustiveVariants deets ->\n            String.join \"\\n\"\n                [ \"There are still some variants that have not been covered for \" ++ cyan deets.unionName\n                , block\n                    (List.map yellow deets.leftOver)\n                , \"Add them to your query so that we know what data to select if they show up!\"\n                ]\n\n        MissingTypename deets ->\n            String.join \"\\n\"\n                [ cyan deets.tag ++ \" needs to select for \" ++ yellow \"__typename\"\n                , block\n                    [ \"... on \" ++ deets.tag ++ \" {\"\n                    , yellow \"    __typename\"\n                    , grey \"    # ... other fields\"\n                    , \"}\"\n                    ]\n                , \"If we don't have this, then we can't be totally sure what type is returned.\"\n                ]\n\n        EmptyUnionVariantSelection deets ->\n            String.join \"\\n\"\n                [ cyan deets.tag ++ \" needs to select at least one field.\"\n                , block\n                    [ \"... on \" ++ deets.tag ++ \" {\"\n                    , yellow \"    __typename\"\n                    , \"}\"\n                    ]\n                , \"If you don't need any more data, just add \" ++ yellow \"__typename\"\n                ]\n\n        IncorrectInlineInput deets ->\n            String.join \"\\n\"\n                [ cyan deets.arg ++ \" has the wrong type. I was expecting:\"\n                , block\n                    [ yellow (GraphQL.Schema.typeToString deets.schema)\n                    ]\n                , \"But found:\"\n                , block\n                    [ yellow (AST.valueToString deets.found)\n                    ]\n                ]\n\n        FragmentNotFound deets ->\n            let\n                fragmentsThatMatchThisObject =\n                    List.filter\n                        (\\frag ->\n                            deets.object == Can.nameToString frag.typeCondition\n                        )\n                        deets.options\n            in\n            case fragmentsThatMatchThisObject of\n                [] ->\n                    case deets.options of\n                        [] ->\n                            String.join \"\\n\"\n                                [ \"I found a usage of a fragment named \" ++ cyan deets.found ++ \", but I don't see any fragments defined in this document!\"\n                                , \"You could add one by adding this if you want.\"\n                                , block\n                                    [ cyan \"fragment\" ++ \" on \" ++ yellow deets.object ++ \" {\"\n                                    , \"    # select some fields here!\"\n                                    , \"}\"\n                                    ]\n                                , \"Check out https://graphql.org/learn/queries/#fragments to learn more!\"\n                                ]\n\n                        _ ->\n                            String.join \"\\n\"\n                                [ \"I don't recognize the fragment named \" ++ cyan deets.found ++ \".\"\n                                , \"Here are the fragments I know about.\"\n                                , block\n                                    (List.map (yellow << Can.nameToString << .name)\n                                        deets.options\n                                    )\n                                ]\n\n                [ single ] ->\n                    String.join \"\\n\"\n                        [ \"I don't recognize the fragment named \" ++ cyan deets.found ++ \".\"\n                        , \"Do you mean?\"\n                        , block\n                            (List.map (yellow << Can.nameToString << .name)\n                                fragmentsThatMatchThisObject\n                            )\n                        ]\n\n                _ ->\n                    String.join \"\\n\"\n                        [ \"I don't recognize the fragment named \" ++ cyan deets.found ++ \".\"\n                        , \"Do you mean one of these?\"\n                        , block\n                            (List.map (yellow << Can.nameToString << .name)\n                                fragmentsThatMatchThisObject\n                            )\n                        ]\n\n        FragmentTargetDoesntExist deets ->\n            String.join \"\\n\"\n                [ \"I found this fragment:\"\n                , block\n                    [ \"fragment \" ++ cyan deets.fragmentName ++ \" on \" ++ yellow deets.typeCondition\n                    ]\n                , \"But I wasn't able to find \" ++ yellow deets.typeCondition ++ \" in the schema.\"\n                , \"Is there a typo?\"\n                ]\n\n        FragmentDuplicateFound deets ->\n            if deets.firstTypeCondition == deets.secondTypeCondition && deets.firstFieldCount == deets.secondFieldCount then\n                String.join \"\\n\"\n                    [ \"I found two fragments with the name \" ++ yellow deets.firstName\n                    , \"Maybe they're just duplicates?\"\n                    , \"Fragments need to have globally unique names. Can you rename one?\"\n                    ]\n\n            else\n                String.join \"\\n\"\n                    [ \"I found two fragments with the name \" ++ yellow deets.firstName\n                    , block\n                        [ \"fragment \" ++ cyan deets.firstName ++ \" on \" ++ yellow deets.firstTypeCondition\n                        , \"fragment \" ++ cyan deets.secondName ++ \" on \" ++ yellow deets.secondTypeCondition\n                        ]\n                    , \"Fragments need to have globally unique names. Can you rename one?\"\n                    ]\n\n        VariableIssueSummary summary ->\n            case summary.declared of\n                [] ->\n                    String.join \"\\n\"\n                        [ \"It looks like no variables are declared.\"\n                        , \"Here's what I think the variables should be:\"\n                        , block\n                            (List.map\n                                renderSuggestion\n                                (List.reverse summary.suggestions)\n                            )\n                        ]\n\n                _ ->\n                    String.join \"\\n\"\n                        [ \"I found the following variables:\"\n                        , block\n                            (List.map\n                                renderDeclared\n                                (List.reverse summary.declared)\n                            )\n                        , if List.length summary.issues == 1 then\n                            \"But I ran into an issue:\"\n\n                          else\n                            \"But I ran into a few issues:\"\n                        , block\n                            (List.concatMap\n                                renderIssue\n                                summary.issues\n                            )\n                        , \"Here's what I think the variables should be:\"\n                        , block\n                            (List.map\n                                renderSuggestion\n                                (List.reverse summary.suggestions)\n                            )\n                        ]\n\n\nrenderDeclared : DeclaredVariable -> String\nrenderDeclared declared =\n    case declared.type_ of\n        Nothing ->\n            yellow (\"$\" ++ declared.name)\n\n        Just declaredType ->\n            yellow (\"$\" ++ declared.name) ++ grey \": \" ++ cyan declaredType\n\n\nrenderSuggestion : SuggestedVariable -> String\nrenderSuggestion sug =\n    yellow (\"$\" ++ sug.name) ++ grey \": \" ++ cyan sug.type_\n\n\nrenderIssue : VarIssue -> List String\nrenderIssue issue =\n    case issue of\n        Unused var ->\n            [ yellow (\"$\" ++ var.name) ++ \" is unused.\" ]\n\n        UnexpectedType var ->\n            case var.found of\n                Nothing ->\n                    [ yellow (\"$\" ++ var.name) ++ \" has no type declaration\" ]\n\n                Just foundType ->\n                    let\n                        variableName =\n                            \"$\" ++ var.name\n                    in\n                    [ yellow variableName\n                        ++ \" is declared as \"\n                        ++ cyan foundType\n                    , String.repeat (String.length variableName - 6) \" \"\n                        ++ \"but is expected to be \"\n                        ++ cyan var.expected\n                    ]\n\n        Undeclared var ->\n            [ yellow (\"$\" ++ var.name) ++ \" is undeclared (missing from the top).\" ]\n\n\ntype CanResult success\n    = CanError (List Error)\n    | CanSuccess VarCache success\n\n\nerr : List Error -> CanResult success\nerr =\n    CanError\n\n\nsuccess : VarCache -> success -> CanResult success\nsuccess =\n    CanSuccess\n\n\nemptySuccess : CanResult (List a)\nemptySuccess =\n    CanSuccess emptyCache []\n\n\ncanonicalize : GraphQL.Schema.Schema -> AST.Document -> Result (List Error) Can.Document\ncanonicalize schema doc =\n    let\n        fragmentResult =\n            List.foldl\n                (getFragments\n                    schema\n                )\n                (Ok Dict.empty)\n                doc.definitions\n    in\n    case fragmentResult of\n        Err fragErrorDetails ->\n            Err (List.map error fragErrorDetails)\n\n        Ok fragments ->\n            let\n                canonicalizedFragments =\n                    List.foldl\n                        (canonicalizeFragment schema)\n                        (CanSuccess emptyCache Dict.empty)\n                        (Dict.values fragments)\n            in\n            case canonicalizedFragments of\n                CanSuccess fragmentCacne canonicalFrags ->\n                    let\n                        canonicalizedDefinitions =\n                            reduce\n                                (canonicalizeDefinition\n                                    { schema = schema\n                                    , fragments =\n                                        canonicalFrags\n                                    }\n                                )\n                                doc.definitions\n                                emptySuccess\n                    in\n                    case canonicalizedDefinitions of\n                        CanSuccess cache defs ->\n                            Ok\n                                { definitions = defs\n                                , fragments = Dict.values canonicalFrags\n                                }\n\n                        CanError errorMsg ->\n                            Err errorMsg\n\n                CanError errorMsg ->\n                    Err errorMsg\n\n\ntype alias References =\n    { schema : GraphQL.Schema.Schema\n    , fragments : Dict String Can.Fragment\n    }\n\n\ntype alias VarCache =\n    { varTypes : List ( String, GraphQL.Schema.Type )\n    }\n\n\nemptyCache : VarCache\nemptyCache =\n    { varTypes = []\n    }\n\n\naddVars vars cache =\n    { varTypes =\n        -- NOTE, there is an opporunity to check if there is avariable collision here\n        -- not a problem if there is a collision, only if they have conflicting gql types\n        vars ++ cache.varTypes\n    }\n\n\nmergeCaches one two =\n    { varTypes =\n        -- NOTE, there is an opporunity to check if there is avariable collision here\n        -- not a problem if there is a collision, only if they have conflicting gql types\n        one.varTypes ++ two.varTypes\n    }\n\n\ngetFragments :\n    GraphQL.Schema.Schema\n    -> AST.Definition\n    -> Result (List ErrorDetails) (Dict String AST.FragmentDetails)\n    -> Result (List ErrorDetails) (Dict String AST.FragmentDetails)\ngetFragments schema def result =\n    case result of\n        Err errs ->\n            Err errs\n\n        Ok frags ->\n            case def of\n                AST.Operation op ->\n                    result\n\n                AST.Fragment frag ->\n                    let\n                        name =\n                            AST.nameToString frag.name\n                    in\n                    case Dict.get name frags of\n                        Nothing ->\n                            frags\n                                |> Dict.insert\n                                    (AST.nameToString frag.name)\n                                    frag\n                                |> Ok\n\n                        Just found ->\n                            Err\n                                [ FragmentDuplicateFound\n                                    { firstName = AST.nameToString frag.name\n                                    , firstTypeCondition = AST.nameToString frag.typeCondition\n                                    , firstFieldCount = List.length frag.selection\n                                    , secondName = AST.nameToString found.name\n                                    , secondTypeCondition = AST.nameToString found.typeCondition\n                                    , secondFieldCount = List.length found.selection\n                                    }\n                                ]\n\n\nreduce :\n    (item -> Maybe (CanResult result))\n    -> List item\n    -> CanResult (List result)\n    -> CanResult (List result)\nreduce isValid items res =\n    case items of\n        [] ->\n            res\n\n        top :: remain ->\n            case isValid top of\n                Nothing ->\n                    reduce isValid remain res\n\n                Just (CanSuccess cache valid) ->\n                    case res of\n                        CanSuccess existingCache existing ->\n                            reduce isValid\n                                remain\n                                (CanSuccess (mergeCaches cache existingCache) (valid :: existing))\n\n                        CanError _ ->\n                            res\n\n                Just (CanError errorMessage) ->\n                    let\n                        newResult =\n                            case res of\n                                CanSuccess _ _ ->\n                                    CanError errorMessage\n\n                                CanError existingErrors ->\n                                    CanError (errorMessage ++ existingErrors)\n                    in\n                    reduce isValid remain newResult\n\n\nconvertName : AST.Name -> Can.Name\nconvertName (AST.Name str) =\n    Can.Name str\n\n\ncanonicalizeDefinition :\n    References\n    -> AST.Definition\n    -> Maybe (CanResult Can.Definition)\ncanonicalizeDefinition refs def =\n    case def of\n        AST.Fragment details ->\n            Nothing\n\n        AST.Operation details ->\n            let\n                globalOperationName =\n                    Maybe.map convertName details.name\n\n                operationType =\n                    case details.operationType of\n                        AST.Query ->\n                            Can.Query\n\n                        AST.Mutation ->\n                            Can.Mutation\n\n                initialNameCache =\n                    UsedNames\n                        { siblingAliases = []\n                        , siblingStack = []\n                        , breadcrumbs = []\n                        , globalNames =\n                            []\n                        }\n                        |> getGlobalName\n                            (globalOperationName\n                                |> Maybe.map Can.nameToString\n                                |> Maybe.withDefault (opTypeName operationType)\n                            )\n\n                fieldResult =\n                    List.foldl\n                        (\\field ( used, result ) ->\n                            case result of\n                                CanSuccess oldCache oldItems ->\n                                    let\n                                        ( newUsed, newResult ) =\n                                            canonicalizeOperation\n                                                refs\n                                                details.operationType\n                                                used\n                                                field\n                                    in\n                                    ( newUsed\n                                    , case newResult of\n                                        CanError errorMessage ->\n                                            CanError errorMessage\n\n                                        CanSuccess newCache validItem ->\n                                            CanSuccess\n                                                (mergeCaches oldCache newCache)\n                                                (validItem :: oldItems)\n                                    )\n\n                                CanError _ ->\n                                    ( used, result )\n                        )\n                        ( initialNameCache.used\n                        , emptySuccess\n                        )\n                        details.fields\n            in\n            Just <|\n                case Tuple.second fieldResult of\n                    CanSuccess cache fields ->\n                        let\n                            variableSummary =\n                                List.foldl\n                                    verifyVariables\n                                    { declared = []\n                                    , valid = []\n                                    , issues = []\n                                    , suggestions = []\n                                    }\n                                    (mergeVars cache.varTypes details.variableDefinitions)\n                        in\n                        if not (List.isEmpty variableSummary.issues) then\n                            CanError\n                                [ error\n                                    (VariableIssueSummary variableSummary)\n                                ]\n\n                        else\n                            CanSuccess cache <|\n                                Can.Operation\n                                    { operationType =\n                                        operationType\n                                    , name = globalOperationName\n                                    , variableDefinitions =\n                                        variableSummary.valid\n                                    , directives =\n                                        List.map convertDirective details.directives\n                                    , fields = fields\n                                    }\n\n                    CanError errorMsg ->\n                        CanError errorMsg\n\n\nopTypeName : Can.OperationType -> String\nopTypeName op =\n    case op of\n        Can.Query ->\n            \"Query\"\n\n        Can.Mutation ->\n            \"Mutation\"\n\n\n{-| The AST.Type is the type declared at the top of the document.\n\nThe Schema.Type is what is in the schema.\n\n-}\ndoTypesMatch : GraphQL.Schema.Type -> AST.Type -> Bool\ndoTypesMatch schemaType astType =\n    case astType of\n        AST.Type_ astName ->\n            case schemaType of\n                GraphQL.Schema.Scalar schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.InputObject schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Object schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Enum schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Union schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Interface schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.List_ inner ->\n                    False\n\n                GraphQL.Schema.Nullable innerSchema ->\n                    -- the query can mark something as required even if it's optional in the schema\n                    doTypesMatch innerSchema astType\n\n        AST.Nullable innerAST ->\n            case schemaType of\n                GraphQL.Schema.Nullable innerSchema ->\n                    doTypesMatch innerSchema innerAST\n\n                _ ->\n                    False\n\n        AST.List_ innerAST ->\n            case schemaType of\n                GraphQL.Schema.List_ innerSchema ->\n                    doTypesMatch innerSchema innerAST\n\n                _ ->\n                    False\n\n\nverifyVariables :\n    { name : String\n    , definition : Maybe AST.VariableDefinition\n    , inOperation : Maybe GraphQL.Schema.Type\n    }\n    -> VariableSummary\n    -> VariableSummary\nverifyVariables item summary =\n    case ( item.definition, item.inOperation ) of\n        ( Just def, Just inOp ) ->\n            -- check to make sure the variables are unifiable\n            let\n                valid =\n                    { variable = { name = convertName def.variable.name }\n                    , type_ = def.type_\n                    , defaultValue = def.defaultValue\n                    , schemaType = inOp\n                    }\n\n                typeString =\n                    GraphQL.Schema.typeToString inOp\n\n                declared =\n                    { name = AST.nameToString def.variable.name\n                    , type_ =\n                        Just\n                            (AST.typeToGqlString def.type_)\n                    }\n\n                suggestion =\n                    { name = AST.nameToString def.variable.name\n                    , type_ = typeString\n                    }\n\n                typesMatch =\n                    doTypesMatch inOp def.type_\n            in\n            { declared = declared :: summary.declared\n            , valid = valid :: summary.valid\n            , issues =\n                if typesMatch then\n                    summary.issues\n\n                else\n                    UnexpectedType\n                        { name = item.name\n                        , found = Just (AST.typeToGqlString def.type_)\n                        , expected = typeString\n                        }\n                        :: summary.issues\n            , suggestions =\n                if typesMatch then\n                    -- we do this so that when we print an error message\n                    -- If the user has specified that this is a required value\n                    -- but the schema says it's optional\n                    -- we maintain the required-ness\n                    { name = AST.nameToString def.variable.name\n                    , type_ =\n                        AST.typeToGqlString def.type_\n                    }\n                        :: summary.suggestions\n\n                else\n                    suggestion :: summary.suggestions\n            }\n\n        ( Just def, Nothing ) ->\n            { declared =\n                { name = AST.nameToString def.variable.name\n                , type_ = Nothing\n                }\n                    :: summary.declared\n            , valid = summary.valid\n            , issues =\n                Unused\n                    { name = item.name\n                    , possibly = []\n                    }\n                    :: summary.issues\n            , suggestions =\n                summary.suggestions\n            }\n\n        ( Nothing, Just inOp ) ->\n            let\n                suggestion =\n                    { name = item.name\n                    , type_ = GraphQL.Schema.typeToString inOp\n                    }\n            in\n            { declared = summary.declared\n            , valid = summary.valid\n            , issues =\n                Undeclared\n                    { name = item.name\n                    , possibly = []\n                    }\n                    :: summary.issues\n            , suggestions = suggestion :: summary.suggestions\n            }\n\n        ( Nothing, Nothing ) ->\n            summary\n\n\nmergeVars :\n    List ( String, GraphQL.Schema.Type )\n    -> List AST.VariableDefinition\n    ->\n        List\n            { name : String\n            , definition : Maybe AST.VariableDefinition\n            , inOperation : Maybe GraphQL.Schema.Type\n            }\nmergeVars varTypes variableDefinitions =\n    let\n        allNames =\n            List.foldl\n                (\\varName found ->\n                    if List.member varName found then\n                        found\n\n                    else\n                        varName :: found\n                )\n                []\n                (List.map (.variable >> .name >> AST.nameToString) variableDefinitions\n                    ++ List.map Tuple.first varTypes\n                )\n                |> List.reverse\n    in\n    List.map\n        (\\name ->\n            { name = name\n            , definition =\n                List.foldl\n                    (\\def found ->\n                        case found of\n                            Nothing ->\n                                if AST.nameToString def.variable.name == name then\n                                    Just def\n\n                                else\n                                    found\n\n                            _ ->\n                                found\n                    )\n                    Nothing\n                    variableDefinitions\n            , inOperation =\n                find name varTypes\n            }\n        )\n        allNames\n\n\nfind : String -> List ( String, a ) -> Maybe a\nfind str items =\n    case items of\n        [] ->\n            Nothing\n\n        ( key, val ) :: remain ->\n            if str == key then\n                Just val\n\n            else\n                find str remain\n\n\ncanonicalizeOperation :\n    References\n    -> AST.OperationType\n    -> UsedNames\n    -> AST.Selection\n    -> ( UsedNames, CanResult Can.Field )\ncanonicalizeOperation refs op used selection =\n    case selection of\n        AST.Field field ->\n            let\n                desiredName =\n                    field.alias_\n                        |> Maybe.withDefault field.name\n                        |> convertName\n                        |> Can.nameToString\n\n                matched =\n                    case op of\n                        AST.Query ->\n                            Dict.get (AST.nameToString field.name) refs.schema.queries\n\n                        AST.Mutation ->\n                            Dict.get (AST.nameToString field.name) refs.schema.mutations\n            in\n            case matched of\n                Nothing ->\n                    ( used, err [ error (QueryUnknown (AST.nameToString field.name)) ] )\n\n                Just query ->\n                    canonicalizeFieldType refs\n                        field\n                        used\n                        query\n                        |> Tuple.mapFirst dropLevel\n\n        AST.FragmentSpreadSelection frag ->\n            ( used, err [ todo \"Fragments in unions aren't suported yet!\" ] )\n\n        AST.InlineFragmentSelection inline ->\n            -- This is when we're selecting a union fragment\n            ( used, err [ todo \"Unions not supported yet\" ] )\n\n\ntype InputValidation\n    = Valid (List ( String, GraphQL.Schema.Type ))\n    | InputError ErrorDetails\n    | Mismatch\n\n\nvalidateInput :\n    References\n    -> GraphQL.Schema.Type\n    -> String\n    -> AST.Value\n    -> InputValidation\nvalidateInput refs schemaType fieldName astValue =\n    case astValue of\n        AST.Var var ->\n            let\n                varname =\n                    AST.nameToString var.name\n            in\n            Valid [ ( varname, schemaType ) ]\n\n        AST.Object keyValues ->\n            case schemaType of\n                GraphQL.Schema.InputObject inputObjectName ->\n                    case Dict.get inputObjectName refs.schema.inputObjects of\n                        Nothing ->\n                            Mismatch\n\n                        Just inputObject ->\n                            validateObject refs fieldName keyValues inputObject\n\n                GraphQL.Schema.Nullable (GraphQL.Schema.InputObject inputObjectName) ->\n                    case Dict.get inputObjectName refs.schema.inputObjects of\n                        Nothing ->\n                            Mismatch\n\n                        Just inputObject ->\n                            validateObject refs fieldName keyValues inputObject\n\n                _ ->\n                    Mismatch\n\n        AST.Str str ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"Int\" ->\n                    Mismatch\n\n                GraphQL.Schema.Scalar \"Float\" ->\n                    Mismatch\n\n                GraphQL.Schema.Scalar \"Boolean\" ->\n                    Mismatch\n\n                GraphQL.Schema.Scalar _ ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Integer int ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"Int\" ->\n                    Valid []\n\n                GraphQL.Schema.Scalar \"Float\" ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Decimal float ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"Float\" ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Boolean bool ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"Boolean\" ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Null ->\n            case schemaType of\n                GraphQL.Schema.Nullable _ ->\n                    Valid []\n\n                _ ->\n                    Mismatch\n\n        AST.Enum enumName ->\n            case schemaType of\n                GraphQL.Schema.Enum _ ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.ListValue list ->\n            case schemaType of\n                GraphQL.Schema.List_ innerList ->\n                    List.foldl\n                        (\\item current ->\n                            case current of\n                                Valid validArgs ->\n                                    case validateInput refs innerList fieldName item of\n                                        Valid newArgs ->\n                                            Valid (newArgs ++ validArgs)\n\n                                        validationError ->\n                                            validationError\n\n                                _ ->\n                                    current\n                        )\n                        (Valid [])\n                        list\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n\nvalidateObject refs fieldName keyValues inputObject =\n    List.foldl\n        (\\( keyName, value ) current ->\n            let\n                key =\n                    AST.nameToString keyName\n            in\n            case current of\n                Valid argValues ->\n                    case List.head (List.filter (\\a -> a.name == key) inputObject.fields) of\n                        Nothing ->\n                            Mismatch\n\n                        Just field ->\n                            case validateInput refs field.type_ fieldName value of\n                                Valid fieldArgs ->\n                                    Valid (argValues ++ fieldArgs)\n\n                                validationError ->\n                                    validationError\n\n                _ ->\n                    current\n        )\n        (Valid [])\n        keyValues\n\n\ntype UsedNames\n    = UsedNames\n        -- sibling errors will cause a compiler error if there is a collision\n        { siblingAliases : List String\n        , siblingStack : List (List String)\n\n        -- All parent aliased names\n        -- we keep track of if something is an alias because\n        -- it can be really intuitive to just use aliases to generate names\n        , breadcrumbs :\n            List\n                { name : String\n                , isAlias : Bool\n                }\n\n        -- All global field aliases\n        , globalNames : List String\n        }\n\n\nformatTypename : String -> String\nformatTypename name =\n    let\n        first =\n            String.left 1 name\n\n        uppercase =\n            String.toUpper first ++ String.dropLeft 1 name\n    in\n    if List.member uppercase builtinNames then\n        uppercase ++ \"_\"\n\n    else\n        uppercase\n\n\nbuiltinNames : List String\nbuiltinNames =\n    [ \"List\"\n    , \"String\"\n    , \"Maybe\"\n    , \"Result\"\n    , \"Bool\"\n    , \"Float\"\n    , \"Int\"\n    ]\n\n\n{-| -}\ngetFragmentOverrideName : List AST.Selection -> String -> String\ngetFragmentOverrideName selectedFields name =\n    case selectedFields of\n        [ AST.FragmentSpreadSelection fragment ] ->\n            AST.nameToString fragment.name\n\n        _ ->\n            name\n\n\n{-| -}\ngetGlobalNameWithFragmentAlias : List AST.Selection -> String -> UsedNames -> { globalName : String, used : UsedNames }\ngetGlobalNameWithFragmentAlias selection name usedNames =\n    getGlobalName (getFragmentOverrideName selection name)\n        usedNames\n\n\n{-|\n\n    This will retrieve a globally unique name.\n    The intention is that an aliased name is passed in.\n    If it's used, then this returns nothing\n    and the query should fail to compile.\n    If not, then a new globally unique name is returend that can be used for code generation.\n\n-}\ngetGlobalName : String -> UsedNames -> { globalName : String, used : UsedNames }\ngetGlobalName rawName (UsedNames used) =\n    if rawName == \"__typename\" then\n        { used = UsedNames used\n        , globalName = \"__typename\"\n        }\n\n    else\n        let\n            name =\n                formatTypename rawName\n\n            newGlobalName =\n                if List.member name used.globalNames then\n                    let\n                        allAliases =\n                            List.filter .isAlias used.breadcrumbs\n                    in\n                    case allAliases of\n                        [] ->\n                            case used.breadcrumbs of\n                                [] ->\n                                    -- shouldnt happen\n                                    name\n\n                                top :: remain ->\n                                    let\n                                        unaliasedName =\n                                            top.name ++ \"_\" ++ name\n                                    in\n                                    if List.member unaliasedName used.globalNames then\n                                        String.join \"_\" (List.reverse (List.map .name used.breadcrumbs)) ++ \"_\" ++ name\n\n                                    else\n                                        unaliasedName\n\n                        topAlias :: remainingAliases ->\n                            let\n                                aliasedName =\n                                    topAlias.name ++ \"_\" ++ name\n                            in\n                            if List.member aliasedName used.globalNames then\n                                String.join \"_\" (List.reverse (List.map .name used.breadcrumbs)) ++ \"_\" ++ name\n\n                            else\n                                aliasedName\n\n                else\n                    name\n        in\n        { used =\n            UsedNames\n                { used\n                    | globalNames =\n                        newGlobalName :: used.globalNames\n                }\n        , globalName = newGlobalName\n        }\n\n\nsaveSibling : String -> UsedNames -> UsedNames\nsaveSibling name (UsedNames used) =\n    UsedNames\n        { used\n            | siblingAliases = formatTypename name :: used.siblingAliases\n        }\n\n\nsiblingCollision : String -> UsedNames -> Bool\nsiblingCollision name (UsedNames used) =\n    List.member (formatTypename name) used.siblingAliases\n\n\n{-|\n\n    levels should be the alias name\n\n-}\naddLevel :\n    { field\n        | name : AST.Name\n        , alias_ : Maybe AST.Name\n    }\n    -> UsedNames\n    -> UsedNames\naddLevel field (UsedNames used) =\n    let\n        aliased =\n            field.alias_\n                |> Maybe.withDefault field.name\n                |> convertName\n                |> Can.nameToString\n    in\n    UsedNames\n        { used\n            | breadcrumbs =\n                { name = formatTypename aliased\n                , isAlias = field.alias_ /= Nothing\n                }\n                    :: used.breadcrumbs\n            , siblingStack = used.siblingAliases :: used.siblingStack\n            , siblingAliases = []\n        }\n\n\n{-| -}\ndropLevel : UsedNames -> UsedNames\ndropLevel (UsedNames used) =\n    UsedNames\n        { used\n            | breadcrumbs = List.drop 1 used.breadcrumbs\n            , siblingStack = List.drop 1 used.siblingStack\n            , siblingAliases =\n                List.head used.siblingStack\n                    |> Maybe.withDefault []\n        }\n\n\n{-| -}\nresetSiblings : UsedNames -> UsedNames -> UsedNames\nresetSiblings (UsedNames to) (UsedNames used) =\n    UsedNames\n        { used\n            | siblingAliases =\n                to.siblingAliases\n        }\n\n\ncanonicalizeFragment :\n    GraphQL.Schema.Schema\n    -> AST.FragmentDetails\n    -> CanResult (Dict String Can.Fragment)\n    -> CanResult (Dict String Can.Fragment)\ncanonicalizeFragment schema frag currentResult =\n    case currentResult of\n        CanError errMsg ->\n            CanError errMsg\n\n        CanSuccess cache existingFrags ->\n            let\n                typeCondition =\n                    AST.nameToString frag.typeCondition\n            in\n            case Dict.get typeCondition schema.objects of\n                Just obj ->\n                    let\n                        aliasedName =\n                            frag.name\n                                |> AST.nameToString\n\n                        selectionResult =\n                            List.foldl\n                                (canonicalizeField\n                                    { schema = schema\n                                    , fragments = existingFrags\n                                    }\n                                    obj\n                                )\n                                { result = CanSuccess cache []\n                                , fieldNames =\n                                    UsedNames\n                                        { siblingAliases = []\n                                        , siblingStack = []\n                                        , breadcrumbs = []\n                                        , globalNames =\n                                            []\n                                        }\n                                }\n                                frag.selection\n                    in\n                    case selectionResult.result of\n                        CanSuccess newCache selection ->\n                            CanSuccess newCache\n                                (existingFrags\n                                    |> Dict.insert (AST.nameToString frag.name)\n                                        { name = convertName frag.name\n                                        , typeCondition = convertName frag.typeCondition\n                                        , directives = List.map convertDirective frag.directives\n                                        , selection =\n                                            Can.FragmentObject\n                                                { selection = selection }\n                                        }\n                                )\n\n                        CanError errorMsg ->\n                            CanError errorMsg\n\n                Nothing ->\n                    case Dict.get typeCondition schema.interfaces of\n                        Just interface ->\n                            CanError\n                                [ error <|\n                                    FragmentTargetDoesntExist\n                                        { fragmentName = AST.nameToString frag.name\n                                        , typeCondition = AST.nameToString frag.typeCondition\n                                        }\n                                ]\n\n                        Nothing ->\n                            case Dict.get typeCondition schema.unions of\n                                Just union ->\n                                    CanError\n                                        [ error <|\n                                            FragmentTargetDoesntExist\n                                                { fragmentName = AST.nameToString frag.name\n                                                , typeCondition = AST.nameToString frag.typeCondition\n                                                }\n                                        ]\n\n                                Nothing ->\n                                    CanError\n                                        [ error <|\n                                            FragmentTargetDoesntExist\n                                                { fragmentName = AST.nameToString frag.name\n                                                , typeCondition = AST.nameToString frag.typeCondition\n                                                }\n                                        ]\n\n\ncanonicalizeField :\n    References\n    ->\n        { obj\n            | name : String\n            , description : Maybe String\n            , fields : List GraphQL.Schema.Field\n        }\n    -> AST.Selection\n    ->\n        { result : CanResult (List Can.Field)\n        , fieldNames : UsedNames\n        }\n    ->\n        { result : CanResult (List Can.Field)\n        , fieldNames : UsedNames\n        }\ncanonicalizeField refs object selection found =\n    case selection of\n        AST.Field field ->\n            let\n                fieldName =\n                    AST.nameToString field.name\n\n                aliased =\n                    AST.getAliasedName field\n            in\n            if siblingCollision aliased found.fieldNames then\n                -- There has been a collision, abort!\n                { result =\n                    err\n                        [ error\n                            (FieldAliasRequired\n                                { fieldName = aliased\n                                }\n                            )\n                        ]\n                , fieldNames = found.fieldNames\n                }\n\n            else if fieldName == \"__typename\" then\n                { result =\n                    addToResult emptyCache\n                        (Can.Field\n                            { alias_ = Maybe.map convertName field.alias_\n                            , name = convertName field.name\n                            , globalAlias =\n                                field.alias_\n                                    |> Maybe.withDefault field.name\n                                    |> convertName\n                            , arguments = []\n                            , directives = List.map convertDirective field.directives\n                            , wrapper = GraphQL.Schema.UnwrappedValue\n                            , selection =\n                                Can.FieldScalar (GraphQL.Schema.Scalar \"typename\")\n                            }\n                        )\n                        found.result\n                , fieldNames = found.fieldNames\n                }\n\n            else\n                let\n                    matchedField =\n                        object.fields\n                            |> List.filter (\\fld -> fld.name == fieldName)\n                            |> List.head\n                in\n                case matchedField of\n                    Just matched ->\n                        let\n                            ( newNames, cannedSelection ) =\n                                canonicalizeFieldType refs\n                                    field\n                                    found.fieldNames\n                                    matched\n                        in\n                        { result =\n                            case cannedSelection of\n                                CanSuccess cache sel ->\n                                    addToResult cache sel found.result\n\n                                CanError errMsg ->\n                                    CanError errMsg\n                        , fieldNames =\n                            newNames\n                                |> saveSibling aliased\n                        }\n\n                    Nothing ->\n                        { result =\n                            err\n                                [ error\n                                    (FieldUnknown\n                                        { object = object.name\n                                        , field = fieldName\n                                        }\n                                    )\n                                ]\n                        , fieldNames = found.fieldNames\n                        }\n\n        AST.FragmentSpreadSelection frag ->\n            let\n                fragName =\n                    AST.nameToString frag.name\n            in\n            case Dict.get fragName refs.fragments of\n                Nothing ->\n                    { result =\n                        err\n                            [ error <|\n                                FragmentNotFound\n                                    { found = fragName\n                                    , object = object.name\n                                    , options =\n                                        Dict.values refs.fragments\n                                    }\n                            ]\n                    , fieldNames = found.fieldNames\n                    }\n\n                Just foundFrag ->\n                    if Can.nameToString foundFrag.typeCondition == object.name then\n                        { result =\n                            addToResult emptyCache\n                                (Can.Frag\n                                    { fragment = foundFrag\n                                    , directives =\n                                        frag.directives\n                                            |> List.map\n                                                convertDirective\n                                    }\n                                )\n                                found.result\n                        , fieldNames = found.fieldNames\n                        }\n\n                    else\n                        { result =\n                            err\n                                [ error <|\n                                    FragmentNotFound\n                                        { found = fragName\n                                        , object = object.name\n                                        , options =\n                                            Dict.values refs.fragments\n                                        }\n                                ]\n                        , fieldNames = found.fieldNames\n                        }\n\n        AST.InlineFragmentSelection inline ->\n            { result = err [ todo \"Inline fragments are not allowed\" ]\n            , fieldNames = found.fieldNames\n            }\n\n\nconvertDirective dir =\n    { name = convertName dir.name\n    , arguments =\n        dir.arguments\n    }\n\n\ncanonicalizeFieldType :\n    References\n    -> AST.FieldDetails\n    -> UsedNames\n    -> GraphQL.Schema.Field\n    ->\n        ( UsedNames\n        , CanResult Can.Field\n        )\ncanonicalizeFieldType refs field usedNames schemaField =\n    canonicalizeFieldTypeHelper refs field schemaField.type_ usedNames emptyCache schemaField\n\n\n{-|\n\n    For `field`, we are matching it up with types from `schema`\n\n-}\ncanonicalizeFieldTypeHelper :\n    References\n    -> AST.FieldDetails\n    -> GraphQL.Schema.Type\n    -> UsedNames\n    -> VarCache\n    -> GraphQL.Schema.Field\n    -> ( UsedNames, CanResult Can.Field )\ncanonicalizeFieldTypeHelper refs field type_ usedNames varCache schemaField =\n    let\n        argValidation =\n            List.foldl\n                (\\arg found ->\n                    let\n                        fieldname =\n                            AST.nameToString arg.name\n                    in\n                    case List.head (List.filter (\\a -> a.name == fieldname) schemaField.arguments) of\n                        Nothing ->\n                            { found\n                                | unknown =\n                                    fieldname :: found.unknown\n                            }\n\n                        Just schemaVar ->\n                            case validateInput refs schemaVar.type_ fieldname arg.value of\n                                Valid vars ->\n                                    { found\n                                        | valid =\n                                            vars ++ found.valid\n                                    }\n\n                                InputError errorDetails ->\n                                    { found\n                                        | errs =\n                                            error errorDetails :: found.errs\n                                    }\n\n                                Mismatch ->\n                                    { found\n                                        | errs =\n                                            error\n                                                (IncorrectInlineInput\n                                                    { schema = schemaVar.type_\n                                                    , arg = fieldname\n                                                    , found = arg.value\n                                                    }\n                                                )\n                                                :: found.errs\n                                    }\n                )\n                { valid = []\n                , unknown = []\n                , errs = []\n                }\n                field.arguments\n    in\n    if not (List.isEmpty argValidation.unknown) then\n        ( usedNames\n        , CanError\n            [ error <|\n                UnknownArgs\n                    { field = AST.nameToString field.name\n                    , unknownArgs = argValidation.unknown\n                    , allowedArgs =\n                        schemaField.arguments\n                    }\n            ]\n        )\n\n    else if not (List.isEmpty argValidation.errs) then\n        ( usedNames, CanError argValidation.errs )\n\n    else\n        let\n            vars =\n                List.reverse argValidation.valid\n\n            newCache =\n                addVars vars varCache\n        in\n        case type_ of\n            GraphQL.Schema.Scalar name ->\n                ( usedNames\n                , success newCache\n                    (Can.Field\n                        { alias_ = Maybe.map convertName field.alias_\n                        , name = convertName field.name\n                        , globalAlias =\n                            field.alias_\n                                |> Maybe.withDefault field.name\n                                |> convertName\n                        , arguments = []\n                        , directives = List.map convertDirective field.directives\n                        , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                        , selection =\n                            Can.FieldScalar schemaField.type_\n                        }\n                    )\n                )\n\n            GraphQL.Schema.InputObject name ->\n                ( usedNames\n                , err [ todo \"Invalid schema!  Weird InputObject\" ]\n                )\n\n            GraphQL.Schema.Object name ->\n                case Dict.get name refs.schema.objects of\n                    Nothing ->\n                        ( usedNames, err [ error (ObjectUnknown name) ] )\n\n                    Just obj ->\n                        canonicalizeObject refs\n                            field\n                            usedNames\n                            schemaField\n                            newCache\n                            obj\n\n            GraphQL.Schema.Enum name ->\n                case Dict.get name refs.schema.enums of\n                    Nothing ->\n                        ( usedNames, err [ error (EnumUnknown name) ] )\n\n                    Just enum ->\n                        ( usedNames\n                        , CanSuccess newCache\n                            (Can.Field\n                                { alias_ = Maybe.map convertName field.alias_\n                                , name = convertName field.name\n                                , globalAlias =\n                                    field.alias_\n                                        |> Maybe.withDefault field.name\n                                        |> convertName\n                                , arguments = []\n                                , directives = List.map convertDirective field.directives\n                                , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                , selection =\n                                    Can.FieldEnum\n                                        { enumName = enum.name\n                                        , values = enum.values\n                                        }\n                                }\n                            )\n                        )\n\n            GraphQL.Schema.Union name ->\n                case Dict.get name refs.schema.unions of\n                    Nothing ->\n                        ( usedNames, err [ error (UnionUnknown name) ] )\n\n                    Just union ->\n                        case extractUnionTags union.variants [] of\n                            Nothing ->\n                                ( usedNames, err [ todo \"Things in a union are not objects!\" ] )\n\n                            Just variants ->\n                                let\n                                    aliasedName =\n                                        field.alias_\n                                            |> Maybe.withDefault field.name\n                                            |> convertName\n                                            |> Can.nameToString\n\n                                    global =\n                                        getGlobalNameWithFragmentAlias\n                                            field.selection\n                                            aliasedName\n                                            usedNames\n\n                                    selectsForTypename =\n                                        List.any\n                                            (\\sel ->\n                                                case sel of\n                                                    AST.Field firstField ->\n                                                        case AST.nameToString firstField.name of\n                                                            \"__typename\" ->\n                                                                True\n\n                                                            _ ->\n                                                                False\n\n                                                    _ ->\n                                                        False\n                                            )\n                                            field.selection\n\n                                    selectionResult =\n                                        List.foldl\n                                            (canonicalizeFieldWithVariants refs\n                                                { name = union.name\n                                                , description = union.description\n                                                , fields = []\n                                                }\n                                            )\n                                            { result = emptySuccess\n                                            , capturedVariants = []\n                                            , fieldNames =\n                                                global.used\n                                                    |> addLevel field\n                                            , variants = variants\n                                            , typenameAlreadySelected = selectsForTypename\n                                            }\n                                            field.selection\n\n                                    ( remainingUsedNames, remaining ) =\n                                        List.foldl\n                                            gatherRemaining\n                                            ( selectionResult.fieldNames\n                                            , []\n                                            )\n                                            selectionResult.variants\n                                in\n                                case selectionResult.result of\n                                    CanSuccess cache canSelection ->\n                                        ( remainingUsedNames\n                                            |> dropLevel\n                                        , CanSuccess (mergeCaches newCache cache)\n                                            (Can.Field\n                                                { alias_ = Maybe.map convertName field.alias_\n                                                , name = convertName field.name\n                                                , globalAlias =\n                                                    Can.Name global.globalName\n                                                , arguments = []\n                                                , directives = List.map convertDirective field.directives\n                                                , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                                , selection =\n                                                    Can.FieldUnion\n                                                        { selection = canSelection\n                                                        , variants = selectionResult.capturedVariants\n                                                        , remainingTags =\n                                                            List.reverse remaining\n                                                        }\n                                                }\n                                            )\n                                        )\n\n                                    CanError errorMsg ->\n                                        ( remainingUsedNames, CanError errorMsg )\n\n            GraphQL.Schema.Interface name ->\n                case Dict.get name refs.schema.interfaces of\n                    Nothing ->\n                        ( usedNames, err [ error (UnionUnknown name) ] )\n\n                    Just interface ->\n                        let\n                            variants =\n                                List.foldl getInterfaceNames [] interface.implementedBy\n\n                            aliasedName =\n                                field.alias_\n                                    |> Maybe.withDefault field.name\n                                    |> convertName\n                                    |> Can.nameToString\n\n                            global =\n                                getGlobalNameWithFragmentAlias\n                                    field.selection\n                                    aliasedName\n                                    usedNames\n\n                            selectsForTypename =\n                                List.any\n                                    (\\sel ->\n                                        case sel of\n                                            AST.Field firstField ->\n                                                case AST.nameToString firstField.name of\n                                                    \"__typename\" ->\n                                                        True\n\n                                                    _ ->\n                                                        False\n\n                                            _ ->\n                                                False\n                                    )\n                                    field.selection\n\n                            selectionResult =\n                                List.foldl\n                                    (canonicalizeFieldWithVariants refs interface)\n                                    { result = emptySuccess\n                                    , capturedVariants = []\n                                    , fieldNames =\n                                        global.used\n                                            |> addLevel field\n                                    , variants = variants\n                                    , typenameAlreadySelected = selectsForTypename\n                                    }\n                                    field.selection\n\n                            ( remainingUsedNames, remaining ) =\n                                List.foldl\n                                    gatherRemaining\n                                    ( selectionResult.fieldNames\n                                    , []\n                                    )\n                                    selectionResult.variants\n                        in\n                        case selectionResult.result of\n                            CanSuccess cache canSelection ->\n                                ( remainingUsedNames\n                                    |> dropLevel\n                                , CanSuccess (mergeCaches newCache cache)\n                                    -- (Can.FieldInterface\n                                    --     { alias_ = Maybe.map convertName field.alias_\n                                    --     , name = convertName field.name\n                                    --     , globalAlias = Can.Name global.globalName\n                                    --     , arguments = field.arguments\n                                    --     , directives = List.map convertDirective field.directives\n                                    --     , selection = canSelection\n                                    --     , variants = selectionResult.capturedVariants\n                                    --     , remainingTags = List.reverse remaining\n                                    --     , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                    --     }\n                                    -- )\n                                    (Can.Field\n                                        { alias_ = Maybe.map convertName field.alias_\n                                        , name = convertName field.name\n                                        , globalAlias =\n                                            Can.Name global.globalName\n                                        , arguments = []\n                                        , directives = List.map convertDirective field.directives\n                                        , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                        , selection =\n                                            Can.FieldInterface\n                                                { selection = canSelection\n                                                , variants = selectionResult.capturedVariants\n                                                , remainingTags =\n                                                    List.reverse remaining\n                                                }\n                                        }\n                                    )\n                                )\n\n                            CanError errorMsg ->\n                                ( selectionResult.fieldNames, CanError errorMsg )\n\n            GraphQL.Schema.List_ inner ->\n                canonicalizeFieldTypeHelper refs field inner usedNames newCache schemaField\n\n            GraphQL.Schema.Nullable inner ->\n                canonicalizeFieldTypeHelper refs field inner usedNames newCache schemaField\n\n\ngatherRemaining tag ( used, gathered ) =\n    let\n        global =\n            getGlobalName tag used\n    in\n    ( global.used\n    , { globalAlias = Can.Name global.globalName\n      , tag = Can.Name tag\n      }\n        :: gathered\n    )\n\n\ncanonicalizeObject :\n    References\n    -> AST.FieldDetails\n    -> UsedNames\n    -> GraphQL.Schema.Field\n    -> VarCache\n    -> GraphQL.Schema.ObjectDetails\n    -> ( UsedNames, CanResult Can.Field )\ncanonicalizeObject refs field usedNames schemaField varCache obj =\n    case field.selection of\n        [] ->\n            -- This is an object with no selection, which isn't allowed for gql.\n            ( usedNames\n            , err\n                [ error\n                    (EmptySelection\n                        { field =\n                            case field.alias_ of\n                                Nothing ->\n                                    AST.nameToString field.name\n\n                                Just alias ->\n                                    AST.nameToString alias\n                                        ++ \": \"\n                                        ++ AST.nameToString field.name\n                        , fieldType = obj.name\n                        , options =\n                            List.map\n                                (\\f ->\n                                    { field = f.name\n                                    , type_ = GraphQL.Schema.typeToString f.type_\n                                    }\n                                )\n                                obj.fields\n                        }\n                    )\n                ]\n            )\n\n        _ ->\n            let\n                aliasedName =\n                    field.alias_\n                        |> Maybe.withDefault field.name\n                        |> convertName\n                        |> Can.nameToString\n\n                global =\n                    getGlobalNameWithFragmentAlias field.selection\n                        aliasedName\n                        usedNames\n\n                selectionResult =\n                    List.foldl\n                        (canonicalizeField refs obj)\n                        { result = emptySuccess\n                        , fieldNames =\n                            global.used\n                                |> addLevel field\n                        }\n                        field.selection\n            in\n            case selectionResult.result of\n                CanSuccess cache canSelection ->\n                    if siblingCollision aliasedName global.used then\n                        ( selectionResult.fieldNames\n                            |> dropLevel\n                        , err\n                            [ error\n                                (FieldAliasRequired\n                                    { fieldName = aliasedName\n                                    }\n                                )\n                            ]\n                        )\n\n                    else\n                        ( selectionResult.fieldNames\n                            |> dropLevel\n                            |> saveSibling aliasedName\n                        , CanSuccess (mergeCaches varCache cache)\n                            (Can.Field\n                                { alias_ = Maybe.map convertName field.alias_\n                                , name = convertName field.name\n                                , globalAlias = Can.Name global.globalName\n                                , arguments = field.arguments\n                                , directives = List.map convertDirective field.directives\n                                , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                , selection =\n                                    Can.FieldObject canSelection\n                                }\n                            )\n                        )\n\n                CanError errorMsg ->\n                    ( global.used, CanError errorMsg )\n\n\ngetInterfaceNames kind found =\n    case kind of\n        GraphQL.Schema.ObjectKind name ->\n            name :: found\n\n        _ ->\n            found\n\n\nextractUnionTags : List GraphQL.Schema.Variant -> List String -> Maybe (List String)\nextractUnionTags vars captured =\n    case vars of\n        [] ->\n            Just captured\n\n        top :: remain ->\n            case top.kind of\n                GraphQL.Schema.ObjectKind name ->\n                    extractUnionTags remain (name :: captured)\n\n                _ ->\n                    Nothing\n\n\naddToResult newCache newItem result =\n    case result of\n        CanSuccess cache existing ->\n            CanSuccess (mergeCaches newCache cache) (newItem :: existing)\n\n        CanError errs ->\n            CanError errs\n\n\naddCache newCache result =\n    case result of\n        CanSuccess cache existing ->\n            CanSuccess (mergeCaches newCache cache) existing\n\n        CanError errs ->\n            CanError errs\n\n\ncanonicalizeFieldWithVariants :\n    References\n    ->\n        { obj\n            | name : String\n            , description : Maybe String\n            , fields : List GraphQL.Schema.Field\n        }\n    -> AST.Selection\n    ->\n        { result : CanResult (List Can.Field)\n        , fieldNames : UsedNames\n        , variants : List String\n        , capturedVariants : List Can.VariantCase\n        , typenameAlreadySelected : Bool\n        }\n    ->\n        { result : CanResult (List Can.Field)\n        , fieldNames : UsedNames\n        , variants : List String\n        , capturedVariants : List Can.VariantCase\n        , typenameAlreadySelected : Bool\n        }\ncanonicalizeFieldWithVariants refs unionOrInterface selection found =\n    case selection of\n        AST.Field field ->\n            let\n                fieldName =\n                    AST.nameToString field.name\n            in\n            --- NOTE, we could probably be more sophisticated here!\n            if fieldName == \"__typename\" then\n                { result =\n                    addToResult emptyCache\n                        (Can.Field\n                            { alias_ = Maybe.map convertName field.alias_\n                            , name = convertName field.name\n                            , globalAlias =\n                                field.alias_\n                                    |> Maybe.withDefault field.name\n                                    |> convertName\n                            , arguments = []\n                            , directives = List.map convertDirective field.directives\n                            , wrapper = GraphQL.Schema.UnwrappedValue\n                            , selection =\n                                Can.FieldScalar (GraphQL.Schema.Scalar \"typename\")\n                            }\n                        )\n                        found.result\n                , fieldNames = found.fieldNames\n                , variants = found.variants\n                , capturedVariants = found.capturedVariants\n                , typenameAlreadySelected = True\n                }\n\n            else\n                let\n                    canned =\n                        canonicalizeField refs\n                            unionOrInterface\n                            selection\n                            { result = found.result\n                            , fieldNames = found.fieldNames\n                            }\n                in\n                { result =\n                    canned.result\n                , fieldNames = canned.fieldNames\n                , variants = found.variants\n                , capturedVariants = found.capturedVariants\n                , typenameAlreadySelected = found.typenameAlreadySelected\n                }\n\n        AST.FragmentSpreadSelection frag ->\n            { result =\n                err [ todo \"Fragments in objects aren't suported yet!\" ]\n            , fieldNames = found.fieldNames\n            , variants = found.variants\n            , capturedVariants = found.capturedVariants\n            , typenameAlreadySelected = found.typenameAlreadySelected\n            }\n\n        AST.InlineFragmentSelection inline ->\n            case inline.selection of\n                [] ->\n                    { result =\n                        err [ error (EmptyUnionVariantSelection { tag = AST.nameToString inline.tag }) ]\n                    , fieldNames = found.fieldNames\n                    , variants = found.variants\n                    , capturedVariants = found.capturedVariants\n                    , typenameAlreadySelected = found.typenameAlreadySelected\n                    }\n\n                _ ->\n                    let\n                        tag =\n                            AST.nameToString inline.tag\n\n                        ( tagMatches, leftOvertags ) =\n                            matchTag tag found.variants ( False, [] )\n                    in\n                    if tagMatches then\n                        case Dict.get tag refs.schema.objects of\n                            Nothing ->\n                                { result =\n                                    err [ error (ObjectUnknown tag) ]\n                                , fieldNames = found.fieldNames\n                                , variants = leftOvertags\n                                , capturedVariants = found.capturedVariants\n                                , typenameAlreadySelected = found.typenameAlreadySelected\n                                }\n\n                            Just obj ->\n                                let\n                                    selectsForTypename =\n                                        if found.typenameAlreadySelected then\n                                            True\n\n                                        else\n                                            List.any\n                                                (\\sel ->\n                                                    case sel of\n                                                        AST.Field firstField ->\n                                                            case AST.nameToString firstField.name of\n                                                                \"__typename\" ->\n                                                                    True\n\n                                                                _ ->\n                                                                    False\n\n                                                        _ ->\n                                                            False\n                                                )\n                                                inline.selection\n\n                                    selectionResult =\n                                        List.foldl\n                                            (\\sel cursor ->\n                                                let\n                                                    canoned =\n                                                        canonicalizeField refs obj sel cursor\n                                                in\n                                                { canoned\n                                                    | fieldNames =\n                                                        -- the weird thing we're doing here is so that field-name-collision\n                                                        -- does not occur within a UnionCase\n                                                        -- meaning separate UnionCases can use the same names and not collide.\n                                                        resetSiblings cursor.fieldNames\n                                                            canoned.fieldNames\n                                                }\n                                            )\n                                            { result = emptySuccess\n                                            , fieldNames = found.fieldNames\n                                            }\n                                            inline.selection\n                                in\n                                if selectsForTypename then\n                                    case selectionResult.result of\n                                        CanSuccess cache canSelection ->\n                                            let\n                                                global =\n                                                    getGlobalName tag selectionResult.fieldNames\n\n                                                globalDetailsAlias =\n                                                    getGlobalNameWithFragmentAlias\n                                                        inline.selection\n                                                        (global.globalName ++ \"_Details\")\n                                                        global.used\n                                            in\n                                            { result =\n                                                found.result\n                                                    |> addCache cache\n\n                                            -- selectionResult.result\n                                            , capturedVariants =\n                                                { tag = Can.Name tag\n                                                , globalTagName = Can.Name global.globalName\n                                                , globalDetailsAlias = Can.Name (global.globalName ++ \"_Details\")\n                                                , directives = List.map convertDirective inline.directives\n                                                , selection = canSelection\n                                                }\n                                                    :: found.capturedVariants\n                                            , fieldNames = global.used\n                                            , variants = leftOvertags\n                                            , typenameAlreadySelected = found.typenameAlreadySelected\n                                            }\n\n                                        CanError errorMsg ->\n                                            { result =\n                                                CanError errorMsg\n                                            , capturedVariants = found.capturedVariants\n                                            , fieldNames = selectionResult.fieldNames\n                                            , variants = leftOvertags\n                                            , typenameAlreadySelected = found.typenameAlreadySelected\n                                            }\n\n                                else\n                                    { result =\n                                        err [ error (MissingTypename { tag = AST.nameToString inline.tag }) ]\n                                    , fieldNames = found.fieldNames\n                                    , capturedVariants = found.capturedVariants\n                                    , variants = found.variants\n                                    , typenameAlreadySelected = found.typenameAlreadySelected\n                                    }\n\n                    else\n                        { result =\n                            err [ todo (tag ++ \" does not match!\") ]\n                        , fieldNames = found.fieldNames\n                        , variants = found.variants\n                        , capturedVariants = found.capturedVariants\n                        , typenameAlreadySelected = found.typenameAlreadySelected\n                        }\n\n\nmatchTag : String -> List String -> ( Bool, List String ) -> ( Bool, List String )\nmatchTag tag tags ( matched, captured ) =\n    case tags of\n        [] ->\n            ( matched, captured )\n\n        top :: remain ->\n            if top == tag then\n                ( True, remain ++ captured )\n\n            else\n                matchTag tag\n                    remain\n                    ( matched, top :: captured )\n"