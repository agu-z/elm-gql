export default (): string => "module GraphQL.Operations.Canonicalize exposing (canonicalize, errorToString)\n\n{-| -}\n\nimport Dict exposing (Dict)\nimport GraphQL.Operations.AST as AST\nimport GraphQL.Operations.CanonicalAST as Can\nimport GraphQL.Schema\nimport Internal.Compiler exposing (formatValue)\n\n\ntype Error\n    = Error\n        { coords : Coords\n        , error : ErrorDetails\n        }\n\n\ntodo : String -> Error\ntodo msg =\n    Error\n        { coords =\n            { start = zeroPosition\n            , end = zeroPosition\n            }\n        , error = Todo msg\n        }\n\n\nerror : ErrorDetails -> Error\nerror deets =\n    Error\n        { coords = { start = zeroPosition, end = zeroPosition }\n        , error = deets\n        }\n\n\nzeroPosition : Position\nzeroPosition =\n    { line = 0\n    , char = 0\n    }\n\n\ntype alias Coords =\n    { start : Position\n    , end : Position\n    }\n\n\ntype alias Position =\n    { line : Int\n    , char : Int\n    }\n\n\ntype ErrorDetails\n    = Todo String\n    | QueryUnknown String\n    | EnumUnknown String\n    | ObjectUnknown String\n    | UnionUnknown String\n    | UnknownArgName String\n    | FieldUnknown\n        { object : String\n        , field : String\n        }\n    | UndeclaredVariable\n        { name : String\n        , knownVariables : List String\n        }\n    | VariableIssueSummary VariableSummary\n    | FieldAliasRequired\n        { fieldName : String\n        }\n    | NonExhaustiveVariants\n        { unionName : String\n        , leftOver : List String\n        }\n    | MissingTypename\n        { tag : String\n        }\n    | EmptyUnionVariantSelection\n        { tag : String\n        }\n    | IncorrectInlineInput\n        { schema : GraphQL.Schema.Type\n        , arg : String\n        , found : AST.Value\n        }\n\n\ntype alias VariableSummary =\n    { declared : List DeclaredVariable\n    , valid : List Can.VariableDefinition\n    , issues : List VarIssue\n    , suggestions : List SuggestedVariable\n    }\n\n\ntype alias DeclaredVariable =\n    { name : String\n    , type_ : Maybe String\n    }\n\n\ntype VarIssue\n    = Unused { name : String, possibly : List String }\n    | UnexpectedType\n        { name : String\n        , found : Maybe String\n        , expected : String\n        }\n    | Undeclared { name : String, possibly : List String }\n\n\ntype alias SuggestedVariable =\n    { name : String\n    , type_ : String\n    }\n\n\n\n{- Error rendering -}\n\n\n{-| An indented block with a newline above and below\n-}\nblock : List String -> String\nblock lines =\n    \"\\n    \" ++ String.join \"\\n    \" lines ++ \"\\n\"\n\n\n\n{-\n   If more colors are wanted, this is a good reference:\n   https://github.com/chalk/chalk/blob/main/source/vendor/ansi-styles/index.js\n-}\n\n\ncyan : String -> String\ncyan str =\n    color 36 39 str\n\n\nyellow : String -> String\nyellow str =\n    color 33 39 str\n\n\ngreen : String -> String\ngreen str =\n    color 32 39 str\n\n\nred : String -> String\nred str =\n    color 31 39 str\n\n\ngrey : String -> String\ngrey str =\n    color 90 39 str\n\n\ncolor : Int -> Int -> String -> String\ncolor openCode closeCode content =\n    let\n        delim code =\n            --\"\\\\u001B[\" ++ String.fromInt code ++ \"m\"\n            \"\\u{001B}[\" ++ String.fromInt code ++ \"m\"\n    in\n    delim openCode ++ content ++ delim closeCode\n\n\n\n{- -}\n\n\nerrorToString : Error -> String\nerrorToString (Error details) =\n    case details.error of\n        Todo msg ->\n            \"Todo: \" ++ msg\n\n        EnumUnknown name ->\n            String.join \"\\n\"\n                [ \"I don't recognize this name:\"\n                , block\n                    [ yellow name ]\n                , \"Add an alias to one of them so there's no confusion!\"\n                ]\n\n        QueryUnknown name ->\n            String.join \"\\n\"\n                [ \"I don't recognize this query:\"\n                , block\n                    [ yellow name ]\n                , \"Add an alias to one of them so there's no confusion!\"\n                ]\n\n        ObjectUnknown name ->\n            String.join \"\\n\"\n                [ \"I don't recognize this object:\"\n                , block\n                    [ yellow name ]\n                , \"Add an alias to one of them so there's no confusion!\"\n                ]\n\n        UnionUnknown name ->\n            String.join \"\\n\"\n                [ \"I don't recognize this union:\"\n                , block\n                    [ yellow name ]\n                , \"Add an alias to one of them so there's no confusion!\"\n                ]\n\n        UnknownArgName name ->\n            \"Unknown argument named: \" ++ name\n\n        FieldUnknown field ->\n            String.join \"\\n\"\n                [ \"You're trying to access\"\n                , block\n                    [ cyan (field.object ++ \".\" ++ field.field)\n                    ]\n                , \"But I don't see a \" ++ cyan field.field ++ \" field on \" ++ cyan field.object\n                ]\n\n        UndeclaredVariable undeclared ->\n            \"Undeclared variable: \" ++ undeclared.name\n\n        FieldAliasRequired deets ->\n            String.join \"\\n\"\n                [ \"I found two fields that have the same name:\"\n                , block\n                    [ yellow deets.fieldName ]\n                , \"Add an alias to one of them so there's no confusion!\"\n                ]\n\n        NonExhaustiveVariants deets ->\n            String.join \"\\n\"\n                [ \"There are still some variants that have not been covered for \" ++ cyan deets.unionName\n                , block\n                    (List.map yellow deets.leftOver)\n                , \"Add them to your query so that we know what data to select if they show up!\"\n                ]\n\n        MissingTypename deets ->\n            String.join \"\\n\"\n                [ cyan deets.tag ++ \" needs to select for \" ++ yellow \"__typename\"\n                , block\n                    [ \"... on \" ++ deets.tag ++ \" {\"\n                    , yellow \"    __typename\"\n                    , grey \"    # ... other fields\"\n                    , \"}\"\n                    ]\n                , \"If we don't have this, then we can't be totally sure what type is returned.\"\n                ]\n\n        EmptyUnionVariantSelection deets ->\n            String.join \"\\n\"\n                [ cyan deets.tag ++ \" needs to select at least one field.\"\n                , block\n                    [ \"... on \" ++ deets.tag ++ \" {\"\n                    , yellow \"    __typename\"\n                    , \"}\"\n                    ]\n                , \"If you don't need any more data, just add \" ++ yellow \"__typename\"\n                ]\n\n        IncorrectInlineInput deets ->\n            String.join \"\\n\"\n                [ cyan deets.arg ++ \" has the wrong type. I was expecting:\"\n                , block\n                    [ yellow (GraphQL.Schema.typeToString deets.schema)\n                    ]\n                , \"But found:\"\n                , block\n                    [ yellow (AST.valueToString deets.found)\n                    ]\n                ]\n\n        VariableIssueSummary summary ->\n            case summary.declared of\n                [] ->\n                    String.join \"\\n\"\n                        [ \"It looks like no variables are declared.\"\n                        , \"Here's what I think the variables should be:\"\n                        , block\n                            (List.map\n                                renderSuggestion\n                                (List.reverse summary.suggestions)\n                            )\n                        ]\n\n                _ ->\n                    String.join \"\\n\"\n                        [ \"I found the following variables:\"\n                        , block\n                            (List.map\n                                renderDeclared\n                                (List.reverse summary.declared)\n                            )\n                        , if List.length summary.issues == 1 then\n                            \"But I ran into an issue:\"\n\n                          else\n                            \"But I ran into a few issues:\"\n                        , block\n                            (List.concatMap\n                                renderIssue\n                                summary.issues\n                            )\n                        , \"Here's what I think the variables should be:\"\n                        , block\n                            (List.map\n                                renderSuggestion\n                                (List.reverse summary.suggestions)\n                            )\n                        ]\n\n\nrenderDeclared : DeclaredVariable -> String\nrenderDeclared declared =\n    case declared.type_ of\n        Nothing ->\n            yellow (\"$\" ++ declared.name)\n\n        Just declaredType ->\n            yellow (\"$\" ++ declared.name) ++ grey \": \" ++ cyan declaredType\n\n\nrenderSuggestion : SuggestedVariable -> String\nrenderSuggestion sug =\n    yellow (\"$\" ++ sug.name) ++ grey \": \" ++ cyan sug.type_\n\n\nrenderIssue : VarIssue -> List String\nrenderIssue issue =\n    case issue of\n        Unused var ->\n            [ yellow (\"$\" ++ var.name) ++ \" is unused.\" ]\n\n        UnexpectedType var ->\n            case var.found of\n                Nothing ->\n                    [ yellow (\"$\" ++ var.name) ++ \" has no type declaration\" ]\n\n                Just foundType ->\n                    let\n                        variableName =\n                            \"$\" ++ var.name\n                    in\n                    [ yellow variableName\n                        ++ \" is declared as \"\n                        ++ cyan foundType\n                    , String.repeat (String.length variableName - 6) \" \"\n                        ++ \"but is expected to be \"\n                        ++ cyan var.expected\n                    ]\n\n        Undeclared var ->\n            [ yellow (\"$\" ++ var.name) ++ \" is undeclared (missing from the top).\" ]\n\n\ntype CanResult success\n    = CanError (List Error)\n    | CanSuccess VarCache success\n\n\nerr : List Error -> CanResult success\nerr =\n    CanError\n\n\nsuccess : VarCache -> success -> CanResult success\nsuccess =\n    CanSuccess\n\n\nemptySuccess : CanResult (List a)\nemptySuccess =\n    CanSuccess emptyCache []\n\n\ncanonicalize : GraphQL.Schema.Schema -> AST.Document -> Result (List Error) Can.Document\ncanonicalize schema doc =\n    let\n        fragments =\n            getFragments schema doc\n    in\n    case reduce (canonicalizeDefinition schema) doc.definitions (CanSuccess fragments []) of\n        CanSuccess cache defs ->\n            case reduceOld (replaceVarTypes cache) defs (Ok []) of\n                Ok defsWithVars ->\n                    Ok { definitions = defsWithVars }\n\n                Err errorMsg ->\n                    Err errorMsg\n\n        CanError errorMsg ->\n            Err errorMsg\n\n\nreplaceVarTypes : VarCache -> Can.Definition -> Result (List Error) Can.Definition\nreplaceVarTypes cache (Can.Operation def) =\n    case reduceOld (getVarTypeNamed cache.varTypes) def.variableDefinitions (Ok []) of\n        Ok varDefs ->\n            Ok\n                (Can.Operation\n                    { def\n                        | variableDefinitions =\n                            varDefs\n                    }\n                )\n\n        Err errMsg ->\n            Err errMsg\n\n\ngetVarTypeNamed : List ( String, GraphQL.Schema.Type ) -> Can.VariableDefinition -> Result (List Error) Can.VariableDefinition\ngetVarTypeNamed vars target =\n    let\n        targetName =\n            Can.nameToString target.variable.name\n\n        found =\n            List.filter\n                (\\( varName, var ) ->\n                    varName == targetName\n                )\n                vars\n                |> List.head\n    in\n    case found of\n        Nothing ->\n            Err [ error (UnknownArgName (\"CANON\" ++ targetName)) ]\n\n        Just ( _, varType ) ->\n            Ok\n                { target\n                    | schemaType = varType\n                }\n\n\ntype alias VarCache =\n    { varTypes : List ( String, GraphQL.Schema.Type )\n    , fragments : Dict String AST.FragmentDetails\n    }\n\n\nemptyCache : VarCache\nemptyCache =\n    { varTypes = []\n    , fragments = Dict.empty\n    }\n\n\naddVars vars cache =\n    { fragments = cache.fragments\n    , varTypes =\n        -- NOTE, there is an opporunity to check if there is avariable collision here\n        -- not a problem if there is a collision, only if they have conflicting gql types\n        vars ++ cache.varTypes\n    }\n\n\nmergeCaches one two =\n    { fragments = one.fragments\n    , varTypes =\n        -- NOTE, there is an opporunity to check if there is avariable collision here\n        -- not a problem if there is a collision, only if they have conflicting gql types\n        one.varTypes ++ two.varTypes\n    }\n\n\ngetFragments : GraphQL.Schema.Schema -> AST.Document -> VarCache\ngetFragments schema doc =\n    gatherFragmentsFromDefinitions schema emptyCache doc.definitions\n\n\ngatherFragmentsFromDefinitions : GraphQL.Schema.Schema -> VarCache -> List AST.Definition -> VarCache\ngatherFragmentsFromDefinitions schema cache defs =\n    case defs of\n        [] ->\n            cache\n\n        (AST.Operation op) :: remain ->\n            cache\n\n        (AST.Fragment frag) :: remain ->\n            gatherFragmentsFromDefinitions schema\n                { cache\n                    | fragments =\n                        Dict.insert\n                            (AST.nameToString frag.name)\n                            frag\n                            cache.fragments\n                }\n                remain\n\n\nreduce :\n    (item -> CanResult result)\n    -> List item\n    -> CanResult (List result)\n    -> CanResult (List result)\nreduce isValid items res =\n    case items of\n        [] ->\n            res\n\n        top :: remain ->\n            case isValid top of\n                CanSuccess cache valid ->\n                    case res of\n                        CanSuccess existingCache existing ->\n                            reduce isValid\n                                remain\n                                (CanSuccess (mergeCaches cache existingCache) (valid :: existing))\n\n                        CanError _ ->\n                            res\n\n                CanError errorMessage ->\n                    let\n                        newResult =\n                            case res of\n                                CanSuccess _ _ ->\n                                    CanError errorMessage\n\n                                CanError existingErrors ->\n                                    CanError (errorMessage ++ existingErrors)\n                    in\n                    reduce isValid remain newResult\n\n\nreduceOld :\n    (item -> Result (List Error) result)\n    -> List item\n    -> Result (List Error) (List result)\n    -> Result (List Error) (List result)\nreduceOld isValid items res =\n    case items of\n        [] ->\n            res\n\n        top :: remain ->\n            case isValid top of\n                Ok valid ->\n                    case res of\n                        Ok existing ->\n                            reduceOld isValid\n                                remain\n                                (Ok (valid :: existing))\n\n                        Err _ ->\n                            res\n\n                Err errorMessage ->\n                    let\n                        newResult =\n                            case res of\n                                Ok _ ->\n                                    Err errorMessage\n\n                                Err existingErrors ->\n                                    Err (errorMessage ++ existingErrors)\n                    in\n                    reduceOld isValid remain newResult\n\n\nreduceConcat :\n    (item -> Result (List Error) (List result))\n    -> List item\n    -> Result (List Error) (List result)\n    -> Result (List Error) (List result)\nreduceConcat isValid items res =\n    case items of\n        [] ->\n            res\n\n        top :: remain ->\n            case isValid top of\n                Ok valid ->\n                    case res of\n                        Ok existing ->\n                            reduceConcat isValid\n                                remain\n                                (Ok (valid ++ existing))\n\n                        Err _ ->\n                            res\n\n                Err errorMessage ->\n                    let\n                        newResult =\n                            case res of\n                                Ok _ ->\n                                    Err errorMessage\n\n                                Err existingErrors ->\n                                    Err (errorMessage ++ existingErrors)\n                    in\n                    reduceConcat isValid remain newResult\n\n\nconvertName : AST.Name -> Can.Name\nconvertName (AST.Name str) =\n    Can.Name str\n\n\ncanonicalizeDefinition : GraphQL.Schema.Schema -> AST.Definition -> CanResult Can.Definition\ncanonicalizeDefinition schema def =\n    case def of\n        AST.Fragment details ->\n            Debug.todo \"There is no concept of fragment in Can.Definition\"\n\n        AST.Operation details ->\n            let\n                fieldResult =\n                    reduce (canonicalizeOperation schema details.operationType) details.fields emptySuccess\n            in\n            case fieldResult of\n                CanSuccess cache fields ->\n                    let\n                        variableSummary =\n                            List.foldl\n                                verifyVariables\n                                { declared = []\n                                , valid = []\n                                , issues = []\n                                , suggestions = []\n                                }\n                                (mergeVars cache.varTypes details.variableDefinitions)\n                    in\n                    if not (List.isEmpty variableSummary.issues) then\n                        CanError\n                            [ error\n                                (VariableIssueSummary variableSummary)\n                            ]\n\n                    else\n                        CanSuccess cache <|\n                            Can.Operation\n                                { operationType =\n                                    case details.operationType of\n                                        AST.Query ->\n                                            Can.Query\n\n                                        AST.Mutation ->\n                                            Can.Mutation\n                                , name = Maybe.map convertName details.name\n                                , variableDefinitions =\n                                    variableSummary.valid\n                                , directives =\n                                    List.map convertDirective details.directives\n                                , fields = fields\n                                }\n\n                CanError errorMsg ->\n                    CanError errorMsg\n\n\n{-| The AST.Type is the type declared at the top of the document.\n\nThe Schema.Type is what is in the schema.\n\n-}\ndoTypesMatch : GraphQL.Schema.Type -> AST.Type -> Bool\ndoTypesMatch schemaType astType =\n    case astType of\n        AST.Type_ astName ->\n            case schemaType of\n                GraphQL.Schema.Scalar schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.InputObject schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Object schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Enum schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Union schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Interface schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.List_ inner ->\n                    False\n\n                GraphQL.Schema.Nullable innerSchema ->\n                    -- the query can mark something as required even if it's optional in the schema\n                    doTypesMatch innerSchema astType\n\n        AST.Nullable innerAST ->\n            case schemaType of\n                GraphQL.Schema.Nullable innerSchema ->\n                    doTypesMatch innerSchema innerAST\n\n                _ ->\n                    False\n\n        AST.List_ innerAST ->\n            case schemaType of\n                GraphQL.Schema.List_ innerSchema ->\n                    doTypesMatch innerSchema innerAST\n\n                _ ->\n                    False\n\n\nverifyVariables :\n    { name : String\n    , definition : Maybe AST.VariableDefinition\n    , inOperation : Maybe GraphQL.Schema.Type\n    }\n    -> VariableSummary\n    -> VariableSummary\nverifyVariables item summary =\n    case ( item.definition, item.inOperation ) of\n        ( Just def, Just inOp ) ->\n            -- check to make sure the variables are unifiable\n            let\n                valid =\n                    { variable = { name = convertName def.variable.name }\n                    , type_ = def.type_\n                    , defaultValue = def.defaultValue\n                    , schemaType = inOp\n                    }\n\n                typeString =\n                    GraphQL.Schema.typeToString inOp\n\n                declared =\n                    { name = AST.nameToString def.variable.name\n                    , type_ =\n                        Just\n                            (AST.typeToGqlString def.type_)\n                    }\n\n                suggestion =\n                    { name = AST.nameToString def.variable.name\n                    , type_ = typeString\n                    }\n\n                typesMatch =\n                    doTypesMatch inOp def.type_\n            in\n            { declared = declared :: summary.declared\n            , valid = valid :: summary.valid\n            , issues =\n                if typesMatch then\n                    summary.issues\n\n                else\n                    UnexpectedType\n                        { name = item.name\n                        , found = Just (AST.typeToGqlString def.type_)\n                        , expected = typeString\n                        }\n                        :: summary.issues\n            , suggestions =\n                if typesMatch then\n                    -- we do this so that when we print an error message\n                    -- If the user has specified that this is a required value\n                    -- but the schema says it's optional\n                    -- we maintain the required-ness\n                    { name = AST.nameToString def.variable.name\n                    , type_ =\n                        AST.typeToGqlString def.type_\n                    }\n                        :: summary.suggestions\n\n                else\n                    suggestion :: summary.suggestions\n            }\n\n        ( Just def, Nothing ) ->\n            { declared =\n                { name = AST.nameToString def.variable.name\n                , type_ = Nothing\n                }\n                    :: summary.declared\n            , valid = summary.valid\n            , issues =\n                Unused\n                    { name = item.name\n                    , possibly = []\n                    }\n                    :: summary.issues\n            , suggestions =\n                summary.suggestions\n            }\n\n        ( Nothing, Just inOp ) ->\n            let\n                suggestion =\n                    { name = item.name\n                    , type_ = GraphQL.Schema.typeToString inOp\n                    }\n            in\n            { declared = summary.declared\n            , valid = summary.valid\n            , issues =\n                Undeclared\n                    { name = item.name\n                    , possibly = []\n                    }\n                    :: summary.issues\n            , suggestions = suggestion :: summary.suggestions\n            }\n\n        ( Nothing, Nothing ) ->\n            summary\n\n\nmergeVars :\n    List ( String, GraphQL.Schema.Type )\n    -> List AST.VariableDefinition\n    ->\n        List\n            { name : String\n            , definition : Maybe AST.VariableDefinition\n            , inOperation : Maybe GraphQL.Schema.Type\n            }\nmergeVars varTypes variableDefinitions =\n    let\n        allNames =\n            List.foldl\n                (\\varName found ->\n                    if List.member varName found then\n                        found\n\n                    else\n                        varName :: found\n                )\n                []\n                (List.map (.variable >> .name >> AST.nameToString) variableDefinitions\n                    ++ List.map Tuple.first varTypes\n                )\n                |> List.reverse\n    in\n    List.map\n        (\\name ->\n            { name = name\n            , definition =\n                List.foldl\n                    (\\def found ->\n                        case found of\n                            Nothing ->\n                                if AST.nameToString def.variable.name == name then\n                                    Just def\n\n                                else\n                                    found\n\n                            _ ->\n                                found\n                    )\n                    Nothing\n                    variableDefinitions\n            , inOperation =\n                find name varTypes\n            }\n        )\n        allNames\n\n\nfind : String -> List ( String, a ) -> Maybe a\nfind str items =\n    case items of\n        [] ->\n            Nothing\n\n        ( key, val ) :: remain ->\n            if str == key then\n                Just val\n\n            else\n                find str remain\n\n\ncanonicalizeOperation :\n    GraphQL.Schema.Schema\n    -> AST.OperationType\n    -> AST.Selection\n    -> CanResult Can.Selection\ncanonicalizeOperation schema op selection =\n    case selection of\n        AST.Field field ->\n            let\n                matched =\n                    case op of\n                        AST.Query ->\n                            Dict.get (AST.nameToString field.name) schema.queries\n\n                        AST.Mutation ->\n                            Dict.get (AST.nameToString field.name) schema.mutations\n            in\n            case matched of\n                Nothing ->\n                    err [ error (QueryUnknown (AST.nameToString field.name)) ]\n\n                Just query ->\n                    let\n                        -- canonicalizeFieldType schema object field type_ usedNames selection schemaField\n                        ( newNames, cannedSelection ) =\n                            canonicalizeFieldType schema field query.type_ [] selection query\n\n                        -- argValidation =\n                        --     reduceConcat (validateArg schema query) field.arguments (Ok [])\n                    in\n                    -- case query.type_ of\n                    --     GraphQL.Schema.Scalar name ->\n                    --         CanSuccess emptyCache\n                    --             (Can.FieldScalar\n                    --                 { alias_ = Maybe.map convertName field.alias_\n                    --                 , name = convertName field.name\n                    --                 , arguments = field.arguments\n                    --                 , directives = List.map convertDirective field.directives\n                    --                 , type_ = query.type_\n                    --                 }\n                    --             )\n                    --     GraphQL.Schema.InputObject name ->\n                    --         err [ todo \"Invalid schema!  Weird InputObject\" ]\n                    --     GraphQL.Schema.Object name ->\n                    --         case Dict.get name schema.objects of\n                    --             Nothing ->\n                    --                 err [ error (ObjectUnknown name) ]\n                    --             Just obj ->\n                    --                 let\n                    --                     selectionResult =\n                    --                         List.foldl\n                    --                             (canonicalizeField schema obj)\n                    --                             { result = emptySuccess\n                    --                             , fieldNames = emptyUsedNames\n                    --                             }\n                    --                             field.selection\n                    --                 in\n                    --                 case argValidation of\n                    --                     Ok vars ->\n                    --                         case selectionResult.result of\n                    --                             CanSuccess cache canSelection ->\n                    --                                 CanSuccess (addVars vars cache)\n                    --                                     (Can.FieldObject\n                    --                                         { alias_ = Maybe.map convertName field.alias_\n                    --                                         , name = convertName field.name\n                    --                                         , arguments = field.arguments\n                    --                                         , directives = List.map convertDirective field.directives\n                    --                                         , selection = canSelection\n                    --                                         , object = obj\n                    --                                         , wrapper = GraphQL.Schema.getWrap query.type_\n                    --                                         }\n                    --                                     )\n                    --                             CanError errorMsg ->\n                    --                                 CanError errorMsg\n                    --                     Err errors ->\n                    --                         CanError errors\n                    --     GraphQL.Schema.Enum name ->\n                    --         case Dict.get name schema.enums of\n                    --             Nothing ->\n                    --                 err [ error (EnumUnknown name) ]\n                    --             Just enum ->\n                    --                 case argValidation of\n                    --                     Ok vars ->\n                    --                         CanSuccess (addVars vars emptyCache)\n                    --                             (Can.FieldEnum\n                    --                                 { alias_ = Maybe.map convertName field.alias_\n                    --                                 , name = convertName field.name\n                    --                                 , arguments = field.arguments\n                    --                                 , directives = List.map convertDirective field.directives\n                    --                                 , enumName = enum.name\n                    --                                 , values = enum.values\n                    --                                 , wrapper = GraphQL.Schema.getWrap query.type_\n                    --                                 }\n                    --                             )\n                    --                     Err errors ->\n                    --                         CanError errors\n                    --     GraphQL.Schema.Union name ->\n                    --         case Dict.get name schema.unions of\n                    --             Nothing ->\n                    --                 err [ error (UnionUnknown name) ]\n                    --             Just union ->\n                    --                 case extractUnionTags union.variants [] of\n                    --                     Nothing ->\n                    --                         err [ todo \"Things in a union are not objects!\" ]\n                    --                     Just vars ->\n                    --                         let\n                    --                             selectsForTypename =\n                    --                                 List.any\n                    --                                     (\\sel ->\n                    --                                         case sel of\n                    --                                             AST.Field firstField ->\n                    --                                                 case AST.nameToString firstField.name of\n                    --                                                     \"__typename\" ->\n                    --                                                         True\n                    --                                                     _ ->\n                    --                                                         False\n                    --                                             _ ->\n                    --                                                 False\n                    --                                     )\n                    --                                     field.selection\n                    --                             selectionResult =\n                    --                                 List.foldl\n                    --                                     (canonicalizeUnionField schema union)\n                    --                                     { result = emptySuccess\n                    --                                     , fieldNames = emptyUsedNames\n                    --                                     , variants = vars\n                    --                                     , typenameAlreadySelected = selectsForTypename\n                    --                                     }\n                    --                                     field.selection\n                    --                         in\n                    --                         case argValidation of\n                    --                             Ok validatedArgs ->\n                    --                                 case selectionResult.result of\n                    --                                     CanSuccess cache canSelection ->\n                    --                                         CanSuccess (addVars validatedArgs cache)\n                    --                                             (Can.FieldUnion\n                    --                                                 { alias_ = Maybe.map convertName field.alias_\n                    --                                                 , name = convertName field.name\n                    --                                                 , arguments = field.arguments\n                    --                                                 , directives = List.map convertDirective field.directives\n                    --                                                 , selection = canSelection\n                    --                                                 , union = union\n                    --                                                 , wrapper = GraphQL.Schema.getWrap query.type_\n                    --                                                 }\n                    --                                             )\n                    --                                     CanError errorMsg ->\n                    --                                         CanError errorMsg\n                    --                             Err errors ->\n                    --                                 CanError errors\n                    --     GraphQL.Schema.Interface name ->\n                    --         err [ todo \"Top level interfaces are not yet supported\" ]\n                    --     GraphQL.Schema.List_ inner ->\n                    --         err [ todo \"Top level lists are not yet supported\" ]\n                    --     GraphQL.Schema.Nullable inner ->\n                    --         err [ todo \"Top level nullables are not yet supported\" ]\n                    cannedSelection\n\n        AST.FragmentSpreadSelection frag ->\n            err [ todo \"Fragments in unions aren't suported yet!\" ]\n\n        AST.InlineFragmentSelection inline ->\n            err [ todo \"Unions not supported yet\" ]\n\n\n{-|\n\n    schema:\n        The actual schema\n\n    spec:\n        The schema definitions for the arguments present on this node\n\n    argsInQuery:\n        The arguments in the operation itself(i.e. the gql file)\n\nThis function both\n\n1.  gathers variables that should be at the top of the query.\n\n-}\nvalidateArg :\n    GraphQL.Schema.Schema\n    -> { node | arguments : List GraphQL.Schema.Argument }\n    -> AST.Argument\n    -> Result (List Error) (List ( String, GraphQL.Schema.Type ))\nvalidateArg schema spec argInQuery =\n    let\n        fieldname =\n            AST.nameToString argInQuery.name\n    in\n    case List.head (List.filter (\\a -> a.name == fieldname) spec.arguments) of\n        Nothing ->\n            Err [ error (UnknownArgName fieldname) ]\n\n        Just schemaVar ->\n            case validateInput schema schemaVar.type_ fieldname argInQuery.value of\n                Valid vars ->\n                    Ok vars\n\n                InputError errorDetails ->\n                    Err [ error errorDetails ]\n\n                Mismatch ->\n                    Err\n                        [ error\n                            (IncorrectInlineInput\n                                { schema = schemaVar.type_\n                                , arg = fieldname\n                                , found = argInQuery.value\n                                }\n                            )\n                        ]\n\n\ntype InputValidation\n    = Valid (List ( String, GraphQL.Schema.Type ))\n    | InputError ErrorDetails\n    | Mismatch\n\n\nvalidateInput :\n    GraphQL.Schema.Schema\n    -> GraphQL.Schema.Type\n    -> String\n    -> AST.Value\n    -> InputValidation\nvalidateInput schema schemaType fieldName astValue =\n    case astValue of\n        AST.Var var ->\n            let\n                varname =\n                    AST.nameToString var.name\n            in\n            Valid [ ( varname, schemaType ) ]\n\n        AST.Object keyValues ->\n            case schemaType of\n                GraphQL.Schema.InputObject inputObjectName ->\n                    case Dict.get inputObjectName schema.inputObjects of\n                        Nothing ->\n                            InputError (UnknownArgName fieldName)\n\n                        Just inputObject ->\n                            List.foldl\n                                (\\( keyName, value ) current ->\n                                    let\n                                        key =\n                                            AST.nameToString keyName\n                                    in\n                                    case current of\n                                        Valid argValues ->\n                                            case List.head (List.filter (\\a -> a.name == key) inputObject.fields) of\n                                                Nothing ->\n                                                    InputError (Todo \"1. All inputs must be variables for now.  No inline values.\")\n\n                                                Just field ->\n                                                    case validateInput schema field.type_ fieldName value of\n                                                        Valid fieldArgs ->\n                                                            Valid (argValues ++ fieldArgs)\n\n                                                        validationError ->\n                                                            validationError\n\n                                        _ ->\n                                            current\n                                )\n                                (Valid [])\n                                keyValues\n\n                _ ->\n                    InputError (UnknownArgName fieldName)\n\n        AST.Str str ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"String\" ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput schema inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Integer int ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"Int\" ->\n                    Valid []\n\n                GraphQL.Schema.Scalar \"Float\" ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput schema inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Decimal float ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"Float\" ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput schema inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Boolean bool ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"Boolean\" ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput schema inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Null ->\n            case schemaType of\n                GraphQL.Schema.Nullable _ ->\n                    Valid []\n\n                _ ->\n                    Mismatch\n\n        AST.Enum enumName ->\n            case schemaType of\n                GraphQL.Schema.Enum _ ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput schema inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.ListValue list ->\n            case schemaType of\n                GraphQL.Schema.List_ innerList ->\n                    List.foldl\n                        (\\item current ->\n                            case current of\n                                Valid validArgs ->\n                                    case validateInput schema innerList fieldName item of\n                                        Valid newArgs ->\n                                            Valid (newArgs ++ validArgs)\n\n                                        validationError ->\n                                            validationError\n\n                                _ ->\n                                    current\n                        )\n                        (Valid [])\n                        list\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput schema inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n\ntype alias UsedNames =\n    List String\n\n\nemptyUsedNames : UsedNames\nemptyUsedNames =\n    []\n\n\ncanonicalizeField :\n    GraphQL.Schema.Schema\n    -> GraphQL.Schema.ObjectDetails\n    -> AST.Selection\n    ->\n        { result : CanResult (List Can.Selection)\n        , fieldNames : UsedNames\n        }\n    ->\n        { result : CanResult (List Can.Selection)\n        , fieldNames : UsedNames\n        }\ncanonicalizeField schema object selection found =\n    case selection of\n        AST.Field field ->\n            let\n                fieldName =\n                    AST.nameToString field.name\n\n                aliased =\n                    AST.getAliasedName field\n            in\n            if List.member aliased found.fieldNames then\n                { result =\n                    err\n                        [ error\n                            (FieldAliasRequired\n                                { fieldName = aliased\n                                }\n                            )\n                        ]\n                , fieldNames = found.fieldNames\n                }\n\n            else if fieldName == \"__typename\" then\n                { result =\n                    addToResult emptyCache\n                        (Can.FieldScalar\n                            { alias_ = Maybe.map convertName field.alias_\n                            , name = convertName field.name\n                            , arguments = []\n                            , directives = List.map convertDirective field.directives\n                            , type_ = GraphQL.Schema.Scalar \"typename\"\n                            }\n                        )\n                        found.result\n                , fieldNames = found.fieldNames\n                }\n\n            else\n                let\n                    matchedField =\n                        object.fields\n                            |> List.filter (\\fld -> fld.name == fieldName)\n                            |> List.head\n                in\n                case matchedField of\n                    Just matched ->\n                        let\n                            ( newNames, cannedSelection ) =\n                                canonicalizeFieldType schema\n                                    field\n                                    matched.type_\n                                    (aliased :: found.fieldNames)\n                                    selection\n                                    matched\n                        in\n                        { result =\n                            case cannedSelection of\n                                CanSuccess cache sel ->\n                                    addToResult cache sel found.result\n\n                                CanError errMsg ->\n                                    CanError errMsg\n                        , fieldNames = newNames\n                        }\n\n                    Nothing ->\n                        { result =\n                            err\n                                [ error\n                                    (FieldUnknown\n                                        { object = object.name\n                                        , field = fieldName\n                                        }\n                                    )\n                                ]\n                        , fieldNames = found.fieldNames\n                        }\n\n        AST.FragmentSpreadSelection frag ->\n            { result = err [ todo \"Fragments in objects aren't suported yet!\" ]\n            , fieldNames = found.fieldNames\n            }\n\n        AST.InlineFragmentSelection inline ->\n            { result = err [ todo \"Inline fragments are not allowed\" ]\n            , fieldNames = found.fieldNames\n            }\n\n\nconvertDirective dir =\n    { name = convertName dir.name\n    , arguments =\n        dir.arguments\n    }\n\n\n{-|\n\n    For `field`, we are matching it up with types from `schema`\n\n-}\ncanonicalizeFieldType :\n    GraphQL.Schema.Schema\n    -> AST.FieldDetails\n    -> GraphQL.Schema.Type\n    -> UsedNames\n    -> AST.Selection\n    -> GraphQL.Schema.Field\n    -> ( UsedNames, CanResult Can.Selection )\ncanonicalizeFieldType schema field type_ usedNames selection schemaField =\n    let\n        argValidation =\n            reduceConcat (validateArg schema schemaField) field.arguments (Ok [])\n    in\n    case argValidation of\n        Err errors ->\n            ( usedNames, CanError errors )\n\n        Ok vars ->\n            case type_ of\n                GraphQL.Schema.Scalar name ->\n                    ( usedNames\n                    , success (addVars vars emptyCache)\n                        (Can.FieldScalar\n                            { alias_ = Maybe.map convertName field.alias_\n                            , name = convertName field.name\n                            , arguments = []\n                            , directives = List.map convertDirective field.directives\n                            , type_ = schemaField.type_\n                            }\n                        )\n                    )\n\n                GraphQL.Schema.InputObject name ->\n                    ( usedNames, err [ todo \"Invalid schema!  Weird InputObject\" ] )\n\n                GraphQL.Schema.Object name ->\n                    case Dict.get name schema.objects of\n                        Nothing ->\n                            ( usedNames, err [ error (ObjectUnknown name) ] )\n\n                        Just obj ->\n                            let\n                                selectionResult =\n                                    List.foldl\n                                        (canonicalizeField schema obj)\n                                        { result = emptySuccess\n                                        , fieldNames = emptyUsedNames\n                                        }\n                                        field.selection\n                            in\n                            case selectionResult.result of\n                                CanSuccess cache canSelection ->\n                                    ( usedNames\n                                    , CanSuccess (addVars vars cache)\n                                        (Can.FieldObject\n                                            { alias_ = Maybe.map convertName field.alias_\n                                            , name = convertName field.name\n                                            , arguments = field.arguments\n                                            , directives = List.map convertDirective field.directives\n                                            , selection = canSelection\n                                            , object = obj\n                                            , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                            }\n                                        )\n                                    )\n\n                                CanError errorMsg ->\n                                    ( usedNames, CanError errorMsg )\n\n                GraphQL.Schema.Enum name ->\n                    case Dict.get name schema.enums of\n                        Nothing ->\n                            ( usedNames, err [ error (EnumUnknown name) ] )\n\n                        Just enum ->\n                            ( usedNames\n                            , CanSuccess (addVars vars emptyCache)\n                                (Can.FieldEnum\n                                    { alias_ = Maybe.map convertName field.alias_\n                                    , name = convertName field.name\n                                    , arguments = field.arguments\n                                    , directives = List.map convertDirective field.directives\n                                    , enumName = enum.name\n                                    , values = enum.values\n                                    , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                    }\n                                )\n                            )\n\n                GraphQL.Schema.Union name ->\n                    case Dict.get name schema.unions of\n                        Nothing ->\n                            ( usedNames, err [ error (UnionUnknown name) ] )\n\n                        Just union ->\n                            case extractUnionTags union.variants [] of\n                                Nothing ->\n                                    ( usedNames, err [ todo \"Things in a union are not objects!\" ] )\n\n                                Just variants ->\n                                    let\n                                        selectsForTypename =\n                                            List.any\n                                                (\\sel ->\n                                                    case sel of\n                                                        AST.Field firstField ->\n                                                            case AST.nameToString firstField.name of\n                                                                \"__typename\" ->\n                                                                    True\n\n                                                                _ ->\n                                                                    False\n\n                                                        _ ->\n                                                            False\n                                                )\n                                                field.selection\n\n                                        selectionResult =\n                                            List.foldl\n                                                (canonicalizeUnionField schema union)\n                                                { result = emptySuccess\n                                                , fieldNames = emptyUsedNames\n                                                , variants = variants\n                                                , typenameAlreadySelected = selectsForTypename\n                                                }\n                                                field.selection\n                                    in\n                                    case selectionResult.result of\n                                        CanSuccess cache canSelection ->\n                                            ( selectionResult.fieldNames\n                                            , case selectionResult.variants of\n                                                [] ->\n                                                    CanSuccess (addVars vars cache)\n                                                        (Can.FieldUnion\n                                                            { alias_ = Maybe.map convertName field.alias_\n                                                            , name = convertName field.name\n                                                            , arguments = []\n                                                            , directives = List.map convertDirective field.directives\n                                                            , selection = canSelection\n                                                            , union = union\n                                                            , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                                            }\n                                                        )\n\n                                                leftover ->\n                                                    err\n                                                        [ error\n                                                            (NonExhaustiveVariants\n                                                                { unionName = name\n                                                                , leftOver = leftover\n                                                                }\n                                                            )\n                                                        ]\n                                            )\n\n                                        CanError errorMsg ->\n                                            ( selectionResult.fieldNames, CanError errorMsg )\n\n                GraphQL.Schema.Interface name ->\n                    ( usedNames, err [ todo \"Field Interfaces!\" ] )\n\n                GraphQL.Schema.List_ inner ->\n                    canonicalizeFieldType schema field inner usedNames selection schemaField\n\n                GraphQL.Schema.Nullable inner ->\n                    canonicalizeFieldType schema field inner usedNames selection schemaField\n\n\nextractUnionTags : List GraphQL.Schema.Variant -> List String -> Maybe (List String)\nextractUnionTags vars captured =\n    case vars of\n        [] ->\n            Just captured\n\n        top :: remain ->\n            case top.kind of\n                GraphQL.Schema.ObjectKind name ->\n                    extractUnionTags remain (name :: captured)\n\n                _ ->\n                    Nothing\n\n\naddToResult newCache newItem result =\n    case result of\n        CanSuccess cache existing ->\n            CanSuccess (mergeCaches newCache cache) (newItem :: existing)\n\n        CanError errs ->\n            CanError errs\n\n\ncanonicalizeUnionField :\n    GraphQL.Schema.Schema\n    -> GraphQL.Schema.UnionDetails\n    -> AST.Selection\n    ->\n        { result : CanResult (List Can.Selection)\n        , fieldNames : UsedNames\n        , variants : List String\n        , typenameAlreadySelected : Bool\n        }\n    ->\n        { result : CanResult (List Can.Selection)\n        , fieldNames : UsedNames\n        , variants : List String\n        , typenameAlreadySelected : Bool\n        }\ncanonicalizeUnionField schema union selection found =\n    case selection of\n        AST.Field field ->\n            let\n                fieldName =\n                    AST.nameToString field.name\n            in\n            --- NOTE, we could probably be more sophisticated here!\n            if fieldName == \"__typename\" then\n                { result =\n                    addToResult emptyCache\n                        (Can.FieldScalar\n                            { alias_ = Maybe.map convertName field.alias_\n                            , name = convertName field.name\n                            , arguments = []\n                            , directives = List.map convertDirective field.directives\n                            , type_ = GraphQL.Schema.Scalar \"typename\"\n                            }\n                        )\n                        found.result\n                , fieldNames = found.fieldNames\n                , variants = found.variants\n                , typenameAlreadySelected = found.typenameAlreadySelected\n                }\n\n            else\n                { result =\n                    err [ todo \"Common selections not allowed for gql unions\" ]\n                , fieldNames = found.fieldNames\n                , variants = found.variants\n                , typenameAlreadySelected = found.typenameAlreadySelected\n                }\n\n        AST.FragmentSpreadSelection frag ->\n            { result =\n                err [ todo \"Fragments in objects aren't suported yet!\" ]\n            , fieldNames = found.fieldNames\n            , variants = found.variants\n            , typenameAlreadySelected = found.typenameAlreadySelected\n            }\n\n        AST.InlineFragmentSelection inline ->\n            case inline.selection of\n                [] ->\n                    { result =\n                        err [ error (EmptyUnionVariantSelection { tag = AST.nameToString inline.tag }) ]\n                    , fieldNames = found.fieldNames\n                    , variants = found.variants\n                    , typenameAlreadySelected = found.typenameAlreadySelected\n                    }\n\n                _ ->\n                    let\n                        tag =\n                            AST.nameToString inline.tag\n\n                        ( tagMatches, leftOvertags ) =\n                            matchTag tag found.variants ( False, [] )\n                    in\n                    if tagMatches then\n                        case Dict.get tag schema.objects of\n                            Nothing ->\n                                { result =\n                                    err [ error (ObjectUnknown tag) ]\n                                , fieldNames = found.fieldNames\n                                , variants = leftOvertags\n                                , typenameAlreadySelected = found.typenameAlreadySelected\n                                }\n\n                            Just obj ->\n                                let\n                                    selectsForTypename =\n                                        if found.typenameAlreadySelected then\n                                            True\n\n                                        else\n                                            List.any\n                                                (\\sel ->\n                                                    case sel of\n                                                        AST.Field firstField ->\n                                                            case AST.nameToString firstField.name of\n                                                                \"__typename\" ->\n                                                                    True\n\n                                                                _ ->\n                                                                    False\n\n                                                        _ ->\n                                                            False\n                                                )\n                                                inline.selection\n\n                                    selectionResult =\n                                        List.foldl\n                                            (canonicalizeField schema obj)\n                                            { result = emptySuccess\n                                            , fieldNames = found.fieldNames\n                                            }\n                                            inline.selection\n                                in\n                                if selectsForTypename then\n                                    case selectionResult.result of\n                                        CanSuccess cache canSelection ->\n                                            { result =\n                                                addToResult cache\n                                                    (Can.UnionCase\n                                                        { tag = Can.Name tag\n                                                        , directives = List.map convertDirective inline.directives\n                                                        , selection = canSelection\n                                                        }\n                                                    )\n                                                    found.result\n                                            , fieldNames = selectionResult.fieldNames\n                                            , variants = leftOvertags\n                                            , typenameAlreadySelected = found.typenameAlreadySelected\n                                            }\n\n                                        CanError errorMsg ->\n                                            { result =\n                                                CanError errorMsg\n                                            , fieldNames = selectionResult.fieldNames\n                                            , variants = leftOvertags\n                                            , typenameAlreadySelected = found.typenameAlreadySelected\n                                            }\n\n                                else\n                                    { result =\n                                        err [ error (MissingTypename { tag = AST.nameToString inline.tag }) ]\n                                    , fieldNames = found.fieldNames\n                                    , variants = found.variants\n                                    , typenameAlreadySelected = found.typenameAlreadySelected\n                                    }\n\n                    else\n                        { result =\n                            err [ todo (tag ++ \" does not match!\") ]\n                        , fieldNames = found.fieldNames\n                        , variants = found.variants\n                        , typenameAlreadySelected = found.typenameAlreadySelected\n                        }\n\n\nmatchTag : String -> List String -> ( Bool, List String ) -> ( Bool, List String )\nmatchTag tag tags ( matched, captured ) =\n    case tags of\n        [] ->\n            ( matched, captured )\n\n        top :: remain ->\n            if top == tag then\n                ( True, remain ++ captured )\n\n            else\n                matchTag tag\n                    remain\n                    ( matched, top :: captured )\n"