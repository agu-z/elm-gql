export default (): string => "module GraphQL.Operations.Canonicalize exposing (canonicalize, errorToString)\n\n{-| -}\n\nimport Dict exposing (Dict)\nimport GraphQL.Operations.AST as AST\nimport GraphQL.Operations.CanonicalAST as Can\nimport GraphQL.Schema\n\n\ntype Error\n    = Error\n        { coords : Coords\n        , error : ErrorDetails\n        }\n\n\ntodo : String -> Error\ntodo msg =\n    Error\n        { coords =\n            { start = zeroPosition\n            , end = zeroPosition\n            }\n        , error = Todo msg\n        }\n\n\nerror : ErrorDetails -> Error\nerror deets =\n    Error\n        { coords = { start = zeroPosition, end = zeroPosition }\n        , error = deets\n        }\n\n\nzeroPosition : Position\nzeroPosition =\n    { line = 0\n    , char = 0\n    }\n\n\ntype alias Coords =\n    { start : Position\n    , end : Position\n    }\n\n\ntype alias Position =\n    { line : Int\n    , char : Int\n    }\n\n\ntype ErrorDetails\n    = Todo String\n    | QueryUnknown String\n    | EnumUnknown String\n    | ObjectUnknown String\n    | UnionUnknown String\n    | UnknownArgName String\n    | FieldUnknown\n        { object : String\n        , field : String\n        }\n\n\nerrorToString : Error -> String\nerrorToString (Error details) =\n    case details.error of\n        Todo msg ->\n            \"Todo: \" ++ msg\n\n        EnumUnknown name ->\n            \"Unknown Enum: \" ++ name\n\n        QueryUnknown name ->\n            \"Unknown Query: \" ++ name\n\n        ObjectUnknown name ->\n            \"Unknown Object: \" ++ name\n\n        UnionUnknown name ->\n            \"Unknown Union: \" ++ name\n\n        UnknownArgName name ->\n            \"Unknown argument named: \" ++ name\n\n        FieldUnknown field ->\n            \"Unknown Field: \" ++ field.object ++ \".\" ++ field.field\n\n\ntype CanResult success\n    = CanError (List Error)\n    | CanSuccess VarCache success\n\n\nerr : List Error -> CanResult success\nerr =\n    CanError\n\n\nsuccess : VarCache -> success -> CanResult success\nsuccess =\n    CanSuccess\n\n\nemptySuccess : CanResult (List a)\nemptySuccess =\n    CanSuccess emptyCache []\n\n\ncanonicalize : GraphQL.Schema.Schema -> AST.Document -> Result (List Error) Can.Document\ncanonicalize schema doc =\n    let\n        fragments =\n            getFragments schema doc\n    in\n    case reduce (canonicalizeDefinition schema) doc.definitions (CanSuccess fragments []) of\n        CanSuccess cache defs ->\n            case reduceOld (replaceVarTypes cache) defs (Ok []) of\n                Ok defsWithVars ->\n                    Ok { definitions = defsWithVars }\n\n                Err errorMsg ->\n                    Err errorMsg\n\n        CanError errorMsg ->\n            Err errorMsg\n\n\nreplaceVarTypes : VarCache -> Can.Definition -> Result (List Error) Can.Definition\nreplaceVarTypes cache (Can.Operation def) =\n    case reduceOld (getVarTypeNamed cache.varTypes) def.variableDefinitions (Ok []) of\n        Ok varDefs ->\n            Ok\n                (Can.Operation\n                    { def\n                        | variableDefinitions =\n                            varDefs\n                    }\n                )\n\n        Err errMsg ->\n            Err errMsg\n\n\ngetVarTypeNamed : List ( String, GraphQL.Schema.Type ) -> Can.VariableDefinition -> Result (List Error) Can.VariableDefinition\ngetVarTypeNamed vars target =\n    let\n        targetName =\n            Can.nameToString target.variable.name\n\n        found =\n            List.filter\n                (\\( varName, var ) ->\n                    varName == targetName\n                )\n                vars\n                |> List.head\n    in\n    case found of\n        Nothing ->\n            Err [ error (UnknownArgName (\"CANON\" ++ targetName)) ]\n\n        Just ( _, varType ) ->\n            Ok\n                { target\n                    | schemaType = varType\n                }\n\n\ntype alias VarCache =\n    { varTypes : List ( String, GraphQL.Schema.Type )\n    , fragments : Dict String AST.FragmentDetails\n    }\n\n\nemptyCache : VarCache\nemptyCache =\n    { varTypes = []\n    , fragments = Dict.empty\n    }\n\n\naddVars vars cache =\n    { fragments = cache.fragments\n    , varTypes =\n        -- NOTE, there is an opporunity to check if there is avariable collision here\n        -- not a problem if there is a collision, only if they have conflicting gql types\n        vars ++ cache.varTypes\n    }\n\n\nmergeCaches one two =\n    { fragments = one.fragments\n    , varTypes =\n        -- NOTE, there is an opporunity to check if there is avariable collision here\n        -- not a problem if there is a collision, only if they have conflicting gql types\n        one.varTypes ++ two.varTypes\n    }\n\n\ngetFragments : GraphQL.Schema.Schema -> AST.Document -> VarCache\ngetFragments schema doc =\n    gatherFragmentsFromDefinitions schema emptyCache doc.definitions\n\n\ngatherFragmentsFromDefinitions schema cache defs =\n    case defs of\n        [] ->\n            cache\n\n        (AST.Operation op) :: remain ->\n            cache\n\n        (AST.Fragment frag) :: remain ->\n            gatherFragmentsFromDefinitions schema\n                { cache\n                    | fragments =\n                        Dict.insert\n                            (AST.nameToString frag.name)\n                            frag\n                            cache.fragments\n                }\n                remain\n\n\nreduce :\n    (item -> CanResult result)\n    -> List item\n    -> CanResult (List result)\n    -> CanResult (List result)\nreduce isValid items res =\n    case items of\n        [] ->\n            res\n\n        top :: remain ->\n            case isValid top of\n                CanSuccess cache valid ->\n                    case res of\n                        CanSuccess existingCache existing ->\n                            reduce isValid\n                                remain\n                                (CanSuccess (mergeCaches cache existingCache) (valid :: existing))\n\n                        CanError _ ->\n                            res\n\n                CanError errorMessage ->\n                    let\n                        newResult =\n                            case res of\n                                CanSuccess _ _ ->\n                                    CanError errorMessage\n\n                                CanError existingErrors ->\n                                    CanError (errorMessage ++ existingErrors)\n                    in\n                    reduce isValid remain newResult\n\n\nreduceOld :\n    (item -> Result (List Error) result)\n    -> List item\n    -> Result (List Error) (List result)\n    -> Result (List Error) (List result)\nreduceOld isValid items res =\n    case items of\n        [] ->\n            res\n\n        top :: remain ->\n            case isValid top of\n                Ok valid ->\n                    case res of\n                        Ok existing ->\n                            reduceOld isValid\n                                remain\n                                (Ok (valid :: existing))\n\n                        Err _ ->\n                            res\n\n                Err errorMessage ->\n                    let\n                        newResult =\n                            case res of\n                                Ok _ ->\n                                    Err errorMessage\n\n                                Err existingErrors ->\n                                    Err (errorMessage ++ existingErrors)\n                    in\n                    reduceOld isValid remain newResult\n\n\nconvertName : AST.Name -> Can.Name\nconvertName (AST.Name str) =\n    Can.Name str\n\n\ncanonicalizeDefinition : GraphQL.Schema.Schema -> AST.Definition -> CanResult Can.Definition\ncanonicalizeDefinition schema def =\n    case def of\n        AST.Fragment details ->\n            Debug.todo \"There is no concept of fragment in Can.Definition\"\n\n        AST.Operation details ->\n            let\n                fieldResult =\n                    reduce (canonicalizeOperation schema details.operationType) details.fields emptySuccess\n            in\n            case fieldResult of\n                CanSuccess cache fields ->\n                    CanSuccess cache <|\n                        Can.Operation\n                            { operationType =\n                                case details.operationType of\n                                    AST.Query ->\n                                        Can.Query\n\n                                    AST.Mutation ->\n                                        Can.Mutation\n                            , name = Maybe.map convertName details.name\n                            , variableDefinitions =\n                                List.map\n                                    toCanonVariable\n                                    details.variableDefinitions\n                            , directives =\n                                List.map convertDirective details.directives\n                            , fields = fields\n                            }\n\n                CanError errorMsg ->\n                    CanError errorMsg\n\n\ntoCanonVariable : AST.VariableDefinition -> Can.VariableDefinition\ntoCanonVariable def =\n    { variable = { name = convertName def.variable.name }\n    , type_ = def.type_\n    , defaultValue = def.defaultValue\n    , schemaType = GraphQL.Schema.Scalar \"Unknown\"\n    }\n\n\ncanonicalizeOperation : GraphQL.Schema.Schema -> AST.OperationType -> AST.Selection -> CanResult Can.Selection\ncanonicalizeOperation schema op selection =\n    case selection of\n        AST.Field field ->\n            let\n                matched =\n                    case op of\n                        AST.Query ->\n                            Dict.get (AST.nameToString field.name) schema.queries\n\n                        AST.Mutation ->\n                            Dict.get (AST.nameToString field.name) schema.mutations\n            in\n            case matched of\n                Nothing ->\n                    err [ error (QueryUnknown (AST.nameToString field.name)) ]\n\n                Just query ->\n                    case query.type_ of\n                        GraphQL.Schema.Scalar name ->\n                            CanSuccess emptyCache\n                                (Can.FieldScalar\n                                    { alias_ = Maybe.map convertName field.alias_\n                                    , name = convertName field.name\n                                    , arguments = []\n                                    , directives = List.map convertDirective field.directives\n                                    , type_ = query.type_\n                                    }\n                                )\n\n                        GraphQL.Schema.InputObject name ->\n                            err [ todo \"Invalid schema!  Weird InputObject\" ]\n\n                        GraphQL.Schema.Object name ->\n                            case Dict.get name schema.objects of\n                                Nothing ->\n                                    err [ error (ObjectUnknown name) ]\n\n                                Just obj ->\n                                    let\n                                        argValidation =\n                                            reduceOld (validateArg query) field.arguments (Ok [])\n\n                                        selectionResult =\n                                            reduce (canonicalizeField schema obj) field.selection emptySuccess\n                                    in\n                                    case argValidation of\n                                        Ok vars ->\n                                            case selectionResult of\n                                                CanSuccess cache canSelection ->\n                                                    CanSuccess (addVars vars cache)\n                                                        (Can.FieldObject\n                                                            { alias_ = Maybe.map convertName field.alias_\n                                                            , name = convertName field.name\n                                                            , arguments = []\n                                                            , directives = List.map convertDirective field.directives\n                                                            , selection = canSelection\n                                                            , object = obj\n                                                            , wrapper = GraphQL.Schema.getWrap query.type_\n                                                            }\n                                                        )\n\n                                                CanError errorMsg ->\n                                                    CanError errorMsg\n\n                                        Err errors ->\n                                            CanError errors\n\n                        GraphQL.Schema.Enum name ->\n                            CanSuccess emptyCache\n                                (Can.FieldScalar\n                                    { alias_ = Maybe.map convertName field.alias_\n                                    , name = convertName field.name\n                                    , arguments = []\n                                    , directives = List.map convertDirective field.directives\n                                    , type_ = query.type_\n                                    }\n                                )\n\n                        GraphQL.Schema.Union name ->\n                            case Dict.get name schema.unions of\n                                Nothing ->\n                                    err [ error (UnionUnknown name) ]\n\n                                Just union ->\n                                    case extractUnionTags union.variants [] of\n                                        Nothing ->\n                                            err [ todo \"Things in a union are not objects!\" ]\n\n                                        Just vars ->\n                                            let\n                                                -- args = reduceOld (validateArg union) field.arguments (Ok [])\n                                                selectionResult =\n                                                    reduce (canonicalizeUnionField schema union vars) field.selection emptySuccess\n                                            in\n                                            case selectionResult of\n                                                CanSuccess cache canSelection ->\n                                                    CanSuccess cache\n                                                        (Can.FieldUnion\n                                                            { alias_ = Maybe.map convertName field.alias_\n                                                            , name = convertName field.name\n                                                            , arguments = []\n                                                            , directives = List.map convertDirective field.directives\n                                                            , selection = canSelection\n                                                            , union = union\n                                                            , wrapper = GraphQL.Schema.getWrap query.type_\n                                                            }\n                                                        )\n\n                                                CanError errorMsg ->\n                                                    CanError errorMsg\n\n                        GraphQL.Schema.Interface name ->\n                            err [ todo \"Handle more object types!\" ]\n\n                        GraphQL.Schema.List_ inner ->\n                            err [ todo \"Handle more object types!\" ]\n\n                        GraphQL.Schema.Nullable inner ->\n                            err [ todo \"Handle more object types!\" ]\n\n        AST.FragmentSpreadSelection frag ->\n            err [ todo \"Fragments in unions aren't suported yet!\" ]\n\n        AST.InlineFragmentSelection inline ->\n            err [ todo \"Unions not supported yet\" ]\n\n\nvalidateArg : { node | arguments : List GraphQL.Schema.Argument } -> AST.Argument -> Result (List Error) ( String, GraphQL.Schema.Type )\nvalidateArg spec argInGql =\n    case argInGql.value of\n        AST.Var var ->\n            let\n                varname =\n                    AST.nameToString var.name\n\n                fieldname =\n                    AST.nameToString argInGql.name\n            in\n            case List.head (List.filter (\\a -> a.name == fieldname) spec.arguments) of\n                Nothing ->\n                    Err [ error (UnknownArgName varname) ]\n\n                Just schemaVar ->\n                    Ok ( varname, schemaVar.type_ )\n\n        _ ->\n            Err [ error (Todo \"All inputs must be variables for now.  No inline values.\") ]\n\n\ncanonicalizeField : GraphQL.Schema.Schema -> GraphQL.Schema.ObjectDetails -> AST.Selection -> CanResult Can.Selection\ncanonicalizeField schema object selection =\n    case selection of\n        AST.Field field ->\n            let\n                fieldName =\n                    AST.nameToString field.name\n            in\n            if fieldName == \"__typename\" then\n                CanSuccess emptyCache\n                    (Can.FieldScalar\n                        { alias_ = Maybe.map convertName field.alias_\n                        , name = convertName field.name\n                        , arguments = []\n                        , directives = List.map convertDirective field.directives\n                        , type_ = GraphQL.Schema.Scalar \"typename\"\n                        }\n                    )\n\n            else\n                let\n                    matchedField =\n                        object.fields\n                            |> List.filter (\\fld -> fld.name == fieldName)\n                            |> List.head\n                in\n                case matchedField of\n                    Just matched ->\n                        canonicalizeFieldType schema object field matched.type_ selection matched.type_\n\n                    Nothing ->\n                        err [ error (FieldUnknown { object = object.name, field = fieldName }) ]\n\n        AST.FragmentSpreadSelection frag ->\n            err [ todo \"Fragments in objects aren't suported yet!\" ]\n\n        AST.InlineFragmentSelection inline ->\n            err [ todo \"Inline fragments are not allowed\" ]\n\n\nconvertDirective dir =\n    { name = convertName dir.name\n    , arguments =\n        List.map\n            (\\arg ->\n                { name = convertName arg.name\n                , value = arg.value\n                }\n            )\n            dir.arguments\n    }\n\n\n{-|\n\n    For `field`, we are matching it up with types from `schema`\n\n-}\ncanonicalizeFieldType : GraphQL.Schema.Schema -> GraphQL.Schema.ObjectDetails -> AST.FieldDetails -> GraphQL.Schema.Type -> AST.Selection -> GraphQL.Schema.Type -> CanResult Can.Selection\ncanonicalizeFieldType schema object field type_ selection originalType =\n    case type_ of\n        GraphQL.Schema.Scalar name ->\n            success emptyCache\n                (Can.FieldScalar\n                    { alias_ = Maybe.map convertName field.alias_\n                    , name = convertName field.name\n                    , arguments = []\n                    , directives = List.map convertDirective field.directives\n                    , type_ = originalType\n                    }\n                )\n\n        GraphQL.Schema.InputObject name ->\n            err [ todo \"Invalid schema!  Weird InputObject\" ]\n\n        GraphQL.Schema.Object name ->\n            case Dict.get name schema.objects of\n                Nothing ->\n                    err [ error (ObjectUnknown name) ]\n\n                Just obj ->\n                    let\n                        -- argValidation = reduceOld (validateArg obj) field.arguments (Ok [])\n                        selectionResult =\n                            reduce (canonicalizeField schema obj) field.selection emptySuccess\n                    in\n                    case selectionResult of\n                        CanSuccess var canSelection ->\n                            CanSuccess var\n                                (Can.FieldObject\n                                    { alias_ = Maybe.map convertName field.alias_\n                                    , name = convertName field.name\n                                    , arguments = []\n                                    , directives = List.map convertDirective field.directives\n                                    , selection = canSelection\n                                    , object = obj\n                                    , wrapper = GraphQL.Schema.getWrap originalType\n                                    }\n                                )\n\n                        CanError errorMsg ->\n                            CanError errorMsg\n\n        GraphQL.Schema.Enum name ->\n            case Dict.get name schema.enums of\n                Nothing ->\n                    err [ error (EnumUnknown name) ]\n\n                Just enum ->\n                    CanSuccess emptyCache\n                        (Can.FieldEnum\n                            { alias_ = Maybe.map convertName field.alias_\n                            , name = convertName field.name\n                            , arguments = []\n                            , directives = List.map convertDirective field.directives\n                            , enumName = enum.name\n                            , values = enum.values\n                            , wrapper = GraphQL.Schema.getWrap originalType\n                            }\n                        )\n\n        GraphQL.Schema.Union name ->\n            case Dict.get name schema.unions of\n                Nothing ->\n                    err [ error (UnionUnknown name) ]\n\n                Just union ->\n                    case extractUnionTags union.variants [] of\n                        Nothing ->\n                            err [ todo \"Things in a union are not objects!\" ]\n\n                        Just vars ->\n                            let\n                                --     args = reduce (validateArg queryObj) field.arguments (Ok [])\n                                selectionResult =\n                                    reduce (canonicalizeUnionField schema union vars) field.selection emptySuccess\n                            in\n                            case selectionResult of\n                                CanSuccess cache canSelection ->\n                                    CanSuccess cache\n                                        (Can.FieldUnion\n                                            { alias_ = Maybe.map convertName field.alias_\n                                            , name = convertName field.name\n                                            , arguments = []\n                                            , directives = List.map convertDirective field.directives\n                                            , selection = canSelection\n                                            , union = union\n                                            , wrapper = GraphQL.Schema.getWrap originalType\n                                            }\n                                        )\n\n                                CanError errorMsg ->\n                                    CanError errorMsg\n\n        GraphQL.Schema.Interface name ->\n            err [ todo \"Field Interfaces!\" ]\n\n        GraphQL.Schema.List_ inner ->\n            canonicalizeFieldType schema object field inner selection originalType\n\n        GraphQL.Schema.Nullable inner ->\n            canonicalizeFieldType schema object field inner selection originalType\n\n\nextractUnionTags : List GraphQL.Schema.Variant -> List String -> Maybe (List String)\nextractUnionTags vars captured =\n    case vars of\n        [] ->\n            Just captured\n\n        top :: remain ->\n            case top.kind of\n                GraphQL.Schema.ObjectKind name ->\n                    extractUnionTags remain (name :: captured)\n\n                _ ->\n                    Nothing\n\n\ncanonicalizeUnionField : GraphQL.Schema.Schema -> GraphQL.Schema.UnionDetails -> List String -> AST.Selection -> CanResult Can.Selection\ncanonicalizeUnionField schema union remainingAllowedTags selection =\n    case selection of\n        AST.Field field ->\n            let\n                fieldName =\n                    AST.nameToString field.name\n            in\n            --- NOTE, we could probably be more sophisticated here!\n            if fieldName == \"__typename\" then\n                CanSuccess emptyCache\n                    (Can.FieldScalar\n                        { alias_ = Maybe.map convertName field.alias_\n                        , name = convertName field.name\n                        , arguments = []\n                        , directives = List.map convertDirective field.directives\n                        , type_ = GraphQL.Schema.Scalar \"typename\"\n                        }\n                    )\n\n            else\n                err [ todo \"Common selections not allowed for gql unions\" ]\n\n        AST.FragmentSpreadSelection frag ->\n            err [ todo \"Fragments in objects aren't suported yet!\" ]\n\n        AST.InlineFragmentSelection inline ->\n            let\n                tag =\n                    AST.nameToString inline.tag\n\n                ( tagMatches, leftOvertags ) =\n                    matchTag tag remainingAllowedTags ( False, [] )\n            in\n            if tagMatches then\n                case Dict.get tag schema.objects of\n                    Nothing ->\n                        err [ error (ObjectUnknown tag) ]\n\n                    Just obj ->\n                        let\n                            --     args = reduce (validateArg queryObj) field.arguments (Ok [])\n                            selectionResult =\n                                reduce (\\sel -> canonicalizeField schema obj sel) inline.selection emptySuccess\n                        in\n                        case selectionResult of\n                            CanSuccess cache canSelection ->\n                                CanSuccess cache\n                                    (Can.UnionCase\n                                        { tag = Can.Name tag\n                                        , directives = List.map convertDirective inline.directives\n                                        , selection = canSelection\n                                        }\n                                    )\n\n                            CanError errorMsg ->\n                                CanError errorMsg\n\n            else\n                err [ todo (tag ++ \" does not match!\") ]\n\n\nmatchTag : String -> List String -> ( Bool, List String ) -> ( Bool, List String )\nmatchTag tag tags ( matched, captured ) =\n    case tags of\n        [] ->\n            ( matched, captured )\n\n        top :: remain ->\n            if top == tag then\n                ( True, remain ++ captured )\n\n            else\n                matchTag tag\n                    remain\n                    ( matched, top :: captured )\n"