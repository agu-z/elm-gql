[{"name":"Elm","comment":"\n\n@docs file, render\n\n@docs Expression\n\n@docs value, valueFrom, valueWith\n\n\n# Primitives\n\n@docs int, float, char, string, hex, unit\n\n@docs list, tuple, triple\n\n@docs record, get\n\n@docs caseOf\n\n@docs apply\n\n@docs lambda\n\n\n# Top level\n\n@docs Declaration, declaration, declarationWith\n\n@docs function, functionWith\n\n@docs alias, aliasWith\n\n@docs customType, customTypeWith\n\n@docs Module, moduleName, moduleAs\n\n@docs withDocumentation, expose, exposeConstructor\n\n\n# Operators\n\n@docs power, multiply, divide, intDivide, modulo, rem, plus, minus, append, cons, equal, notEqual, lt, gt, lte, gte, and, or, pipe, pipeLeft, compose, composeLeft\n\n\n# Package specific operators\n\n@docs keep, skip, slash, questionMark\n\n\n# Ports\n\n@docs portIncoming, portOutgoing\n\n\n# Util\n\n@docs File\n\n@docs pass\n\n","unions":[{"name":"File","comment":" ","args":[],"cases":[]}],"aliases":[{"name":"Declaration","comment":" ","args":[],"type":"Internal.Compiler.Declaration"},{"name":"Expression","comment":" ","args":[],"type":"Internal.Compiler.Expression"},{"name":"Module","comment":" ","args":[],"type":"Internal.Compiler.Module"}],"values":[{"name":"alias","comment":" A custom type declaration.\n\n    Elm.alias \"MyAlias\"\n        (Elm.Annotation.record\n            [ ( \"one\", Elm.Annotation.string )\n            , ( \"two\", Elm.Annotation.int )\n            ]\n        )\n\nShould result in\n\n    type alias MyAlias =\n        { one : String\n        , two : int\n        }\n\n","type":"String.String -> Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"aliasWith","comment":" You may need type variables.\n\nElm.aliasWith \"MyMaybe\" [\"a\"]\n(Elm.Annotation.maybe (Elm.Annotation.var \"a\"))\n\n","type":"String.String -> List.List String.String -> Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"and","comment":" `&&`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"append","comment":" `++`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"apply","comment":" ","type":"Elm.Expression -> List.List Elm.Expression -> Elm.Expression"},{"name":"caseOf","comment":" ","type":"Elm.Expression -> List.List ( Elm.Pattern, Elm.Expression ) -> Elm.Expression"},{"name":"char","comment":" ","type":"Char.Char -> Elm.Expression"},{"name":"compose","comment":" `>>`.\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"composeLeft","comment":" `<<`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"cons","comment":" `::`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"customType","comment":" A custom type declaration.\n\n    Elm.customType \"MyType\"\n        [ ( \"One\", [] )\n        , ( \"Two\", [ Elm.Annotation.list Elm.Annotation.string ] )\n        ]\n\nShould result in\n\n    type MyType\n        = One\n        | Two (List String)\n\n","type":"String.String -> List.List ( String.String, List.List Elm.Annotation.Annotation ) -> Elm.Declaration"},{"name":"customTypeWith","comment":" If you want type variables in your custom type!\n","type":"String.String -> List.List String.String -> List.List ( String.String, List.List Elm.Annotation.Annotation ) -> Elm.Declaration"},{"name":"declaration","comment":" ","type":"String.String -> Elm.Expression -> Elm.Declaration"},{"name":"declarationWith","comment":" If you have a specific type signature you would like you can add it here.\n\nNote, this library will autocalculate many type signatures! Make sure `Elm.declaration` doesnt already do this automatically for you!\n\n","type":"String.String -> Elm.Annotation.Annotation -> Elm.Expression -> Elm.Declaration"},{"name":"divide","comment":" `/`.\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"equal","comment":" `==`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"expose","comment":" ","type":"Elm.Declaration -> Elm.Declaration"},{"name":"exposeConstructor","comment":" ","type":"Elm.Declaration -> Elm.Declaration"},{"name":"file","comment":" Build a file!\n\n    Elm.file (Elm.moduleName [ \"My\", \"Module\" ])\n        [ Elm.declaration \"placeholder\"\n            (Elm.string \"a fancy string!\")\n        ]\n\nOnce you have a file, you can render it using `Elm.toString`.\n\n","type":"Elm.Module -> List.List Elm.Declaration -> Elm.File"},{"name":"float","comment":" ","type":"Basics.Float -> Elm.Expression"},{"name":"function","comment":" Declare a function. Here's an example with a let:\n\n    import Elm.Pattern as Pattern\n\n    Elm.function \"myFunc\"\n        [ Pattern.var \"one\"\n        , Pattern.var \"two\"\n        ]\n        (Elm.letIn\n            [ Let.value \"added\"\n                (Elm.add (Elm.value \"one\") (Elm.value \"two))\n            ]\n            (Elm.add (Elm.value \"added\") (Elm.int 5))\n        )\n\nwill generate\n\n    myFunc one two =\n        let\n            added =\n                one + two\n        in\n        added + 5\n\n","type":"String.String -> List.List Elm.Pattern -> Elm.Expression -> Elm.Declaration"},{"name":"functionWith","comment":" ","type":"String.String -> List.List ( Elm.Annotation.Annotation, Elm.Pattern ) -> Elm.Expression -> Elm.Declaration"},{"name":"get","comment":"\n\n    record\n        |> Elm.get \"field\"\n\nresults in\n\n    record.field\n\n","type":"String.String -> Elm.Expression -> Elm.Expression"},{"name":"gt","comment":" `>`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"gte","comment":" `>=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"hex","comment":" ","type":"Basics.Int -> Elm.Expression"},{"name":"int","comment":" ","type":"Basics.Int -> Elm.Expression"},{"name":"intDivide","comment":" `//`.\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"keep","comment":" used in the `elm/parser` library\n\n`|=`\n\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"lambda","comment":" ","type":"List.List Elm.Pattern -> Elm.Expression -> Elm.Expression"},{"name":"list","comment":" ","type":"List.List Elm.Expression -> Elm.Expression"},{"name":"lt","comment":" `<`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"lte","comment":" `<=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"minus","comment":" `-`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"moduleAs","comment":" A modules name\n\n        Elm.moduleAs\n            [ \"Html\"\n            , \"Attributes\"\n            ]\n            \"Html\"\n\n    will refer to\n\n        Html.Attributes as Html\n\n","type":"List.List String.String -> String.String -> Elm.Module"},{"name":"moduleName","comment":" A modules name\n\n        Elm.moduleName\n            [ \"Html\"\n            , \"Attributes\"\n            ]\n\n    will refer to\n\n        Html.Attributes\n\nNote also that this will force capitalization on each segment to prevent silly errors.\n\n","type":"List.List String.String -> Elm.Module"},{"name":"modulo","comment":" `%`.\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"multiply","comment":" `*`.\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"notEqual","comment":" `/=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"or","comment":" `||`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"pass","comment":" ","type":"Internal.Compiler.Expression"},{"name":"pipe","comment":" `|>`\n\n    Elm.value \"thang\"\n        |> Elm.pipe (Elm.value \"thang2\")\n        |> Elm.pipe (Elm.value \"thang3\")\n\n    Results in\n\n    thang\n        |> thang2\n        |> thang3\n\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"pipeLeft","comment":" `<|`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"plus","comment":" `+`.\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"portIncoming","comment":"\n\n    import Elm.Annotation as Type\n\n    Elm.portIncoming \"receiveMessageFromTheWorld\" [ Type.string, Type.int ]\n\nResults in\n\n    port receiveMessageFromTheWorld : (String -> Int -> msg) -> Sub msg\n\n**Note** You generally only need one incoming and one outgoing port!\n\nIf you want to vary the messages going in and out of your app, don't use a huge number of ports, instead write Json encoders and decoders.\n\nThis will give you more flexibility in the future and save you having to wire up a bunch of stuff.\n\n**Another note** - You may need to expose your port explicitly using `Elm.expose`\n\n","type":"String.String -> List.List Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"portOutgoing","comment":" Create a port that can send messages to the outside world!\n\n    import Elm.Annotation as Type\n\n    Elm.portOutgoing \"tellTheWorld\" Type.string\n\nwill generate\n\n    port tellTheWorld : String -> Cmd msg\n\n","type":"String.String -> Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"power","comment":" The to-the-power-of operator `^`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"questionMark","comment":" `<?>` used in url parsing\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"record","comment":" ","type":"List.List ( String.String, Elm.Expression ) -> Elm.Expression"},{"name":"rem","comment":" `rem`.\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"render","comment":" Turn the AST into a pretty printed file\n","type":"Elm.File -> { path : String.String, contents : String.String }"},{"name":"skip","comment":" `|.`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"slash","comment":" `</>` used in url parsing\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"string","comment":" ","type":"String.String -> Elm.Expression"},{"name":"triple","comment":" ","type":"Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"tuple","comment":" ","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"unit","comment":" ","type":"Elm.Expression"},{"name":"value","comment":" ","type":"String.String -> Elm.Expression"},{"name":"valueFrom","comment":" ","type":"Elm.Module -> String.String -> Elm.Expression"},{"name":"valueWith","comment":" Add an annotation to a value.\n\n**Note** this may not _literally_ add an annotation to the code, but will inform `elm-prefab`s type inference so that top level values can be auto-annotated.\n\nSo, for example, if we have.\n\n    Elm.list\n        [ Elm.valueWith myModule \"myString\" Elm.Annotation.string\n        , Elm.valueWith myModule \"myOtherString\" Elm.Annotation.string\n        ]\n\nThen, when that list is generated, it will automatically have the type signature `List String`\n\n","type":"Elm.Module -> String.String -> Elm.Annotation.Annotation -> Elm.Expression"},{"name":"withDocumentation","comment":" Add documentation to a declaration!\n","type":"String.String -> Elm.Declaration -> Elm.Declaration"}],"binops":[]},{"name":"Elm.Annotation","comment":"\n\n@docs Annotation, var, bool, int, float, string, char, unit\n\n@docs named, namedWith\n\n@docs list, tuple, triple, set, dict, maybe, record, extensible\n\n@docs function\n\n","unions":[],"aliases":[{"name":"Annotation","comment":" ","args":[],"type":"Internal.Compiler.Annotation"}],"values":[{"name":"bool","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"char","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"dict","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"extensible","comment":" ","type":"String.String -> List.List ( String.String, Elm.Annotation.Annotation ) -> Elm.Annotation.Annotation"},{"name":"float","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"function","comment":" ","type":"List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"int","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"list","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"maybe","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"named","comment":" ","type":"Elm.Annotation.Module -> String.String -> Elm.Annotation.Annotation"},{"name":"namedWith","comment":" ","type":"Elm.Annotation.Module -> String.String -> List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"record","comment":" ","type":"List.List ( String.String, Elm.Annotation.Annotation ) -> Elm.Annotation.Annotation"},{"name":"set","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"string","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"triple","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"tuple","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"unit","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"var","comment":" A type variable\n","type":"String.String -> Elm.Annotation.Annotation"}],"binops":[]},{"name":"Elm.Debug","comment":"\n\n@docs annotation\n\n","unions":[],"aliases":[],"values":[{"name":"annotation","comment":" Print out what elm-prefab thinks the type signature is at any given point.\n","type":"(String.String -> Result.Result (List.List Internal.Compiler.InferenceError) Elm.Syntax.TypeAnnotation.TypeAnnotation -> Result.Result (List.List Internal.Compiler.InferenceError) Elm.Syntax.TypeAnnotation.TypeAnnotation) -> String.String -> Elm.Debug.Expression -> Elm.Debug.Expression"}],"binops":[]},{"name":"Elm.Let","comment":"\n\n@docs Declaration, value, valueWith\n\n@docs function\n\n","unions":[],"aliases":[{"name":"Declaration","comment":" ","args":[],"type":"Internal.Compiler.LetDeclaration"}],"values":[{"name":"function","comment":" ","type":"String.String -> List.List Elm.Pattern.Pattern -> Elm.Let.Expression -> Elm.Let.Declaration"},{"name":"value","comment":" ","type":"String.String -> Elm.Let.Expression -> Elm.Let.Declaration"},{"name":"valueWith","comment":" ","type":"Elm.Pattern.Pattern -> Elm.Let.Expression -> Elm.Let.Declaration"}],"binops":[]},{"name":"Elm.Pattern","comment":"\n\n@docs Pattern, var, unit, char, string, int, hex, float\n\n@docs tuple, triple, fields, cons, list, named, namedFrom, withAlias\n\n@docs wildcard\n\n","unions":[],"aliases":[{"name":"Pattern","comment":" ","args":[],"type":"Elm.Syntax.Pattern.Pattern"}],"values":[{"name":"char","comment":"\n\n    'c'\n\n","type":"Char.Char -> Elm.Pattern.Pattern"},{"name":"cons","comment":" ","type":"Elm.Pattern.Pattern -> Elm.Pattern.Pattern -> Elm.Pattern.Pattern"},{"name":"fields","comment":"\n\n    Elm.Pattern.fields\n        [ \"field1\"\n        , \"field2\"\n        ]\n\nresults in\n\n    { field1, field2}\n\n","type":"List.List String.String -> Elm.Pattern.Pattern"},{"name":"float","comment":" ","type":"Basics.Float -> Elm.Pattern.Pattern"},{"name":"hex","comment":"\n\n    0x11\n\n","type":"Basics.Int -> Elm.Pattern.Pattern"},{"name":"int","comment":" ","type":"Basics.Int -> Elm.Pattern.Pattern"},{"name":"list","comment":" ","type":"List.List Elm.Pattern.Pattern -> Elm.Pattern.Pattern"},{"name":"named","comment":"\n\n    Elm.Pattern.named \"Just\" [ Elm.Pattern.var \"value\" ]\n\nwould result in the following unpacking\n\n    Just value\n\n","type":"String.String -> List.List Elm.Pattern.Pattern -> Elm.Pattern.Pattern"},{"name":"namedFrom","comment":" Same as `named`, but from a specific module.\n\n    result = Elm.moduleName [\"Result\" ]\n\n    Elm.Pattern.namedFrom result \"Ok\" [ Elm.Pattern.var \"value\" ]\n\nwould result in\n\n    Result.Ok value\n\n","type":"Elm.Pattern.Module -> String.String -> List.List Elm.Pattern.Pattern -> Elm.Pattern.Pattern"},{"name":"string","comment":" ","type":"String.String -> Elm.Pattern.Pattern"},{"name":"triple","comment":" ","type":"Elm.Pattern.Pattern -> Elm.Pattern.Pattern -> Elm.Pattern.Pattern -> Elm.Pattern.Pattern"},{"name":"tuple","comment":"\n\n    Elm.Pattern.tuple\n        (Elm.Pattern.var \"one\")\n        (Elm.Pattern.var \"two\")\n\nresults in\n\n    ( one, two )\n\n","type":"Elm.Pattern.Pattern -> Elm.Pattern.Pattern -> Elm.Pattern.Pattern"},{"name":"unit","comment":"\n\n    `()`\n\n","type":"Elm.Pattern.Pattern"},{"name":"var","comment":" A simple variable name!\n\nThis is what you want 90% of the time.\n\n","type":"String.String -> Elm.Pattern.Pattern"},{"name":"wildcard","comment":" The catchall `_` pattern.\n","type":"Elm.Pattern.Pattern"},{"name":"withAlias","comment":" This is equivalent to `as` in Elm.\n\nSometimes you want to unpack some stuff, but also keep a reference to the top level thing.\n\n    Pattern.withAlias \"fullTuple\"\n        (Pattern.tuple\n            (Pattern.var \"one\")\n            (Pattern.var \"two\")\n        )\n\nresults in\n\n    ((one, two) as fullTuple)\n\n","type":"String.String -> Elm.Pattern.Pattern -> Elm.Pattern.Pattern"}],"binops":[]}]